/**
 * Autogenerated by Thrift
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 */
package com.twitter.zipkin.gen;

import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.EnumMap;
import java.util.Set;
import java.util.HashSet;
import java.util.EnumSet;
import java.util.Collections;
import java.util.BitSet;
import java.nio.ByteBuffer;
import java.util.Arrays;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.thrift.*;
import org.apache.thrift.async.*;
import org.apache.thrift.meta_data.*;
import org.apache.thrift.transport.*;
import org.apache.thrift.protocol.*;

public class ZipkinQuery {

  public interface Iface {

    public QueryResponse getTraceIds(QueryRequest request) throws QueryException, TException;

    /**
     * Fetch trace ids by service and span name.
     * Gets "limit" number of entries from before the "end_ts".
     * 
     * Span name is optional.
     * Timestamps are in microseconds.
     * 
     * @param service_name
     * @param span_name
     * @param end_ts
     * @param limit
     * @param order
     */
    public List<Long> getTraceIdsBySpanName(String service_name, String span_name, long end_ts, int limit, Order order) throws QueryException, TException;

    /**
     * Fetch trace ids by service name.
     * Gets "limit" number of entries from before the "end_ts".
     * 
     * Timestamps are in microseconds.
     * 
     * @param service_name
     * @param end_ts
     * @param limit
     * @param order
     */
    public List<Long> getTraceIdsByServiceName(String service_name, long end_ts, int limit, Order order) throws QueryException, TException;

    /**
     * Fetch trace ids with a particular annotation.
     * Gets "limit" number of entries from before the "end_ts".
     * 
     * When requesting based on time based annotations only pass in the first parameter, "annotation" and leave out
     * the second "value". If looking for a key-value binary annotation provide both, "annotation" is then the
     * key in the key-value.
     * 
     * Timestamps are in microseconds.
     * 
     * @param service_name
     * @param annotation
     * @param value
     * @param end_ts
     * @param limit
     * @param order
     */
    public List<Long> getTraceIdsByAnnotation(String service_name, String annotation, ByteBuffer value, long end_ts, int limit, Order order) throws QueryException, TException;

    /**
     * Get the traces that are in the database from the given list of trace ids.
     * 
     * @param trace_ids
     */
    public Set<Long> tracesExist(List<Long> trace_ids) throws QueryException, TException;

    /**
     * Get the full traces associated with the given trace ids.
     * 
     * Second argument is a list of methods of adjusting the trace
     * data before returning it. Can be empty.
     * 
     * @param trace_ids
     * @param adjust
     */
    public List<Trace> getTracesByIds(List<Long> trace_ids, List<Adjust> adjust) throws QueryException, TException;

    /**
     * Get the trace timelines associated with the given trace ids.
     * This is a convenience method for users that just want to know
     * the annotations and the (assumed) order they happened in.
     * 
     * Second argument is a list of methods of adjusting the trace
     * data before returning it. Can be empty.
     * 
     * Note that if one of the trace ids does not have any data associated with it, it will not be
     * represented in the output list.
     * 
     * @param trace_ids
     * @param adjust
     */
    public List<TraceTimeline> getTraceTimelinesByIds(List<Long> trace_ids, List<Adjust> adjust) throws QueryException, TException;

    /**
     * Fetch trace summaries for the given trace ids.
     * 
     * Second argument is a list of methods of adjusting the trace
     * data before returning it. Can be empty.
     * 
     * Note that if one of the trace ids does not have any data associated with it, it will not be
     * represented in the output list.
     * 
     * @param trace_ids
     * @param adjust
     */
    public List<TraceSummary> getTraceSummariesByIds(List<Long> trace_ids, List<Adjust> adjust) throws QueryException, TException;

    /**
     * Not content with just one of traces, summaries or timelines? Want it all? This is the method for you.
     * 
     * @param trace_ids
     * @param adjust
     */
    public List<TraceCombo> getTraceCombosByIds(List<Long> trace_ids, List<Adjust> adjust) throws QueryException, TException;

    /**
     * Fetch all the service names we have seen from now all the way back to the set ttl.
     */
    public Set<String> getServiceNames() throws QueryException, TException;

    /**
     * Get all the seen span names for a particular service, from now back until the set ttl.
     * 
     * @param service_name
     */
    public Set<String> getSpanNames(String service_name) throws QueryException, TException;

    /**
     * Change the TTL of a trace. If we find an interesting trace we want to keep around for further
     * investigation.
     * 
     * @param trace_id
     * @param ttl_seconds
     */
    public void setTraceTimeToLive(long trace_id, int ttl_seconds) throws QueryException, TException;

    /**
     * Get the TTL in seconds of a specific trace.
     * 
     * @param trace_id
     */
    public int getTraceTimeToLive(long trace_id) throws QueryException, TException;

    /**
     * Get the data ttl. This is the number of seconds we keep the data around before deleting it.
     */
    public int getDataTimeToLive() throws QueryException, TException;

    /**
     * Aggregates related
     * 
     * @param service_name
     */
    public List<String> getDependencies(String service_name) throws QueryException, TException;

    public List<String> getTopAnnotations(String service_name) throws QueryException, TException;

    public List<String> getTopKeyValueAnnotations(String service_name) throws QueryException, TException;

  }

  public interface AsyncIface {

    public void getTraceIds(QueryRequest request, AsyncMethodCallback<AsyncClient.getTraceIds_call> resultHandler) throws TException;

    public void getTraceIdsBySpanName(String service_name, String span_name, long end_ts, int limit, Order order, AsyncMethodCallback<AsyncClient.getTraceIdsBySpanName_call> resultHandler) throws TException;

    public void getTraceIdsByServiceName(String service_name, long end_ts, int limit, Order order, AsyncMethodCallback<AsyncClient.getTraceIdsByServiceName_call> resultHandler) throws TException;

    public void getTraceIdsByAnnotation(String service_name, String annotation, ByteBuffer value, long end_ts, int limit, Order order, AsyncMethodCallback<AsyncClient.getTraceIdsByAnnotation_call> resultHandler) throws TException;

    public void tracesExist(List<Long> trace_ids, AsyncMethodCallback<AsyncClient.tracesExist_call> resultHandler) throws TException;

    public void getTracesByIds(List<Long> trace_ids, List<Adjust> adjust, AsyncMethodCallback<AsyncClient.getTracesByIds_call> resultHandler) throws TException;

    public void getTraceTimelinesByIds(List<Long> trace_ids, List<Adjust> adjust, AsyncMethodCallback<AsyncClient.getTraceTimelinesByIds_call> resultHandler) throws TException;

    public void getTraceSummariesByIds(List<Long> trace_ids, List<Adjust> adjust, AsyncMethodCallback<AsyncClient.getTraceSummariesByIds_call> resultHandler) throws TException;

    public void getTraceCombosByIds(List<Long> trace_ids, List<Adjust> adjust, AsyncMethodCallback<AsyncClient.getTraceCombosByIds_call> resultHandler) throws TException;

    public void getServiceNames(AsyncMethodCallback<AsyncClient.getServiceNames_call> resultHandler) throws TException;

    public void getSpanNames(String service_name, AsyncMethodCallback<AsyncClient.getSpanNames_call> resultHandler) throws TException;

    public void setTraceTimeToLive(long trace_id, int ttl_seconds, AsyncMethodCallback<AsyncClient.setTraceTimeToLive_call> resultHandler) throws TException;

    public void getTraceTimeToLive(long trace_id, AsyncMethodCallback<AsyncClient.getTraceTimeToLive_call> resultHandler) throws TException;

    public void getDataTimeToLive(AsyncMethodCallback<AsyncClient.getDataTimeToLive_call> resultHandler) throws TException;

    public void getDependencies(String service_name, AsyncMethodCallback<AsyncClient.getDependencies_call> resultHandler) throws TException;

    public void getTopAnnotations(String service_name, AsyncMethodCallback<AsyncClient.getTopAnnotations_call> resultHandler) throws TException;

    public void getTopKeyValueAnnotations(String service_name, AsyncMethodCallback<AsyncClient.getTopKeyValueAnnotations_call> resultHandler) throws TException;

  }

  public static class Client implements TServiceClient, Iface {
    public static class Factory implements TServiceClientFactory<Client> {
      public Factory() {}
      public Client getClient(TProtocol prot) {
        return new Client(prot);
      }
      public Client getClient(TProtocol iprot, TProtocol oprot) {
        return new Client(iprot, oprot);
      }
    }

    public Client(TProtocol prot)
    {
      this(prot, prot);
    }

    public Client(TProtocol iprot, TProtocol oprot)
    {
      iprot_ = iprot;
      oprot_ = oprot;
    }

    protected TProtocol iprot_;
    protected TProtocol oprot_;

    protected int seqid_;

    public TProtocol getInputProtocol()
    {
      return this.iprot_;
    }

    public TProtocol getOutputProtocol()
    {
      return this.oprot_;
    }

    public QueryResponse getTraceIds(QueryRequest request) throws QueryException, TException
    {
      send_getTraceIds(request);
      return recv_getTraceIds();
    }

    public void send_getTraceIds(QueryRequest request) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getTraceIds", TMessageType.CALL, ++seqid_));
      getTraceIds_args args = new getTraceIds_args();
      args.setRequest(request);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public QueryResponse recv_getTraceIds() throws QueryException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getTraceIds failed: out of sequence response");
      }
      getTraceIds_result result = new getTraceIds_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.qe != null) {
        throw result.qe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTraceIds failed: unknown result");
    }

    public List<Long> getTraceIdsBySpanName(String service_name, String span_name, long end_ts, int limit, Order order) throws QueryException, TException
    {
      send_getTraceIdsBySpanName(service_name, span_name, end_ts, limit, order);
      return recv_getTraceIdsBySpanName();
    }

    public void send_getTraceIdsBySpanName(String service_name, String span_name, long end_ts, int limit, Order order) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getTraceIdsBySpanName", TMessageType.CALL, ++seqid_));
      getTraceIdsBySpanName_args args = new getTraceIdsBySpanName_args();
      args.setService_name(service_name);
      args.setSpan_name(span_name);
      args.setEnd_ts(end_ts);
      args.setLimit(limit);
      args.setOrder(order);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Long> recv_getTraceIdsBySpanName() throws QueryException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getTraceIdsBySpanName failed: out of sequence response");
      }
      getTraceIdsBySpanName_result result = new getTraceIdsBySpanName_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.qe != null) {
        throw result.qe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTraceIdsBySpanName failed: unknown result");
    }

    public List<Long> getTraceIdsByServiceName(String service_name, long end_ts, int limit, Order order) throws QueryException, TException
    {
      send_getTraceIdsByServiceName(service_name, end_ts, limit, order);
      return recv_getTraceIdsByServiceName();
    }

    public void send_getTraceIdsByServiceName(String service_name, long end_ts, int limit, Order order) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getTraceIdsByServiceName", TMessageType.CALL, ++seqid_));
      getTraceIdsByServiceName_args args = new getTraceIdsByServiceName_args();
      args.setService_name(service_name);
      args.setEnd_ts(end_ts);
      args.setLimit(limit);
      args.setOrder(order);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Long> recv_getTraceIdsByServiceName() throws QueryException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getTraceIdsByServiceName failed: out of sequence response");
      }
      getTraceIdsByServiceName_result result = new getTraceIdsByServiceName_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.qe != null) {
        throw result.qe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTraceIdsByServiceName failed: unknown result");
    }

    public List<Long> getTraceIdsByAnnotation(String service_name, String annotation, ByteBuffer value, long end_ts, int limit, Order order) throws QueryException, TException
    {
      send_getTraceIdsByAnnotation(service_name, annotation, value, end_ts, limit, order);
      return recv_getTraceIdsByAnnotation();
    }

    public void send_getTraceIdsByAnnotation(String service_name, String annotation, ByteBuffer value, long end_ts, int limit, Order order) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getTraceIdsByAnnotation", TMessageType.CALL, ++seqid_));
      getTraceIdsByAnnotation_args args = new getTraceIdsByAnnotation_args();
      args.setService_name(service_name);
      args.setAnnotation(annotation);
      args.setValue(value);
      args.setEnd_ts(end_ts);
      args.setLimit(limit);
      args.setOrder(order);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Long> recv_getTraceIdsByAnnotation() throws QueryException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getTraceIdsByAnnotation failed: out of sequence response");
      }
      getTraceIdsByAnnotation_result result = new getTraceIdsByAnnotation_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.qe != null) {
        throw result.qe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTraceIdsByAnnotation failed: unknown result");
    }

    public Set<Long> tracesExist(List<Long> trace_ids) throws QueryException, TException
    {
      send_tracesExist(trace_ids);
      return recv_tracesExist();
    }

    public void send_tracesExist(List<Long> trace_ids) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("tracesExist", TMessageType.CALL, ++seqid_));
      tracesExist_args args = new tracesExist_args();
      args.setTrace_ids(trace_ids);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Set<Long> recv_tracesExist() throws QueryException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "tracesExist failed: out of sequence response");
      }
      tracesExist_result result = new tracesExist_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.qe != null) {
        throw result.qe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "tracesExist failed: unknown result");
    }

    public List<Trace> getTracesByIds(List<Long> trace_ids, List<Adjust> adjust) throws QueryException, TException
    {
      send_getTracesByIds(trace_ids, adjust);
      return recv_getTracesByIds();
    }

    public void send_getTracesByIds(List<Long> trace_ids, List<Adjust> adjust) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getTracesByIds", TMessageType.CALL, ++seqid_));
      getTracesByIds_args args = new getTracesByIds_args();
      args.setTrace_ids(trace_ids);
      args.setAdjust(adjust);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<Trace> recv_getTracesByIds() throws QueryException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getTracesByIds failed: out of sequence response");
      }
      getTracesByIds_result result = new getTracesByIds_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.qe != null) {
        throw result.qe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTracesByIds failed: unknown result");
    }

    public List<TraceTimeline> getTraceTimelinesByIds(List<Long> trace_ids, List<Adjust> adjust) throws QueryException, TException
    {
      send_getTraceTimelinesByIds(trace_ids, adjust);
      return recv_getTraceTimelinesByIds();
    }

    public void send_getTraceTimelinesByIds(List<Long> trace_ids, List<Adjust> adjust) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getTraceTimelinesByIds", TMessageType.CALL, ++seqid_));
      getTraceTimelinesByIds_args args = new getTraceTimelinesByIds_args();
      args.setTrace_ids(trace_ids);
      args.setAdjust(adjust);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<TraceTimeline> recv_getTraceTimelinesByIds() throws QueryException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getTraceTimelinesByIds failed: out of sequence response");
      }
      getTraceTimelinesByIds_result result = new getTraceTimelinesByIds_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.qe != null) {
        throw result.qe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTraceTimelinesByIds failed: unknown result");
    }

    public List<TraceSummary> getTraceSummariesByIds(List<Long> trace_ids, List<Adjust> adjust) throws QueryException, TException
    {
      send_getTraceSummariesByIds(trace_ids, adjust);
      return recv_getTraceSummariesByIds();
    }

    public void send_getTraceSummariesByIds(List<Long> trace_ids, List<Adjust> adjust) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getTraceSummariesByIds", TMessageType.CALL, ++seqid_));
      getTraceSummariesByIds_args args = new getTraceSummariesByIds_args();
      args.setTrace_ids(trace_ids);
      args.setAdjust(adjust);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<TraceSummary> recv_getTraceSummariesByIds() throws QueryException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getTraceSummariesByIds failed: out of sequence response");
      }
      getTraceSummariesByIds_result result = new getTraceSummariesByIds_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.qe != null) {
        throw result.qe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTraceSummariesByIds failed: unknown result");
    }

    public List<TraceCombo> getTraceCombosByIds(List<Long> trace_ids, List<Adjust> adjust) throws QueryException, TException
    {
      send_getTraceCombosByIds(trace_ids, adjust);
      return recv_getTraceCombosByIds();
    }

    public void send_getTraceCombosByIds(List<Long> trace_ids, List<Adjust> adjust) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getTraceCombosByIds", TMessageType.CALL, ++seqid_));
      getTraceCombosByIds_args args = new getTraceCombosByIds_args();
      args.setTrace_ids(trace_ids);
      args.setAdjust(adjust);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<TraceCombo> recv_getTraceCombosByIds() throws QueryException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getTraceCombosByIds failed: out of sequence response");
      }
      getTraceCombosByIds_result result = new getTraceCombosByIds_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.qe != null) {
        throw result.qe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTraceCombosByIds failed: unknown result");
    }

    public Set<String> getServiceNames() throws QueryException, TException
    {
      send_getServiceNames();
      return recv_getServiceNames();
    }

    public void send_getServiceNames() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getServiceNames", TMessageType.CALL, ++seqid_));
      getServiceNames_args args = new getServiceNames_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Set<String> recv_getServiceNames() throws QueryException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getServiceNames failed: out of sequence response");
      }
      getServiceNames_result result = new getServiceNames_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.qe != null) {
        throw result.qe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getServiceNames failed: unknown result");
    }

    public Set<String> getSpanNames(String service_name) throws QueryException, TException
    {
      send_getSpanNames(service_name);
      return recv_getSpanNames();
    }

    public void send_getSpanNames(String service_name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getSpanNames", TMessageType.CALL, ++seqid_));
      getSpanNames_args args = new getSpanNames_args();
      args.setService_name(service_name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public Set<String> recv_getSpanNames() throws QueryException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getSpanNames failed: out of sequence response");
      }
      getSpanNames_result result = new getSpanNames_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.qe != null) {
        throw result.qe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getSpanNames failed: unknown result");
    }

    public void setTraceTimeToLive(long trace_id, int ttl_seconds) throws QueryException, TException
    {
      send_setTraceTimeToLive(trace_id, ttl_seconds);
      recv_setTraceTimeToLive();
    }

    public void send_setTraceTimeToLive(long trace_id, int ttl_seconds) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("setTraceTimeToLive", TMessageType.CALL, ++seqid_));
      setTraceTimeToLive_args args = new setTraceTimeToLive_args();
      args.setTrace_id(trace_id);
      args.setTtl_seconds(ttl_seconds);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public void recv_setTraceTimeToLive() throws QueryException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "setTraceTimeToLive failed: out of sequence response");
      }
      setTraceTimeToLive_result result = new setTraceTimeToLive_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.qe != null) {
        throw result.qe;
      }
      return;
    }

    public int getTraceTimeToLive(long trace_id) throws QueryException, TException
    {
      send_getTraceTimeToLive(trace_id);
      return recv_getTraceTimeToLive();
    }

    public void send_getTraceTimeToLive(long trace_id) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getTraceTimeToLive", TMessageType.CALL, ++seqid_));
      getTraceTimeToLive_args args = new getTraceTimeToLive_args();
      args.setTrace_id(trace_id);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public int recv_getTraceTimeToLive() throws QueryException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getTraceTimeToLive failed: out of sequence response");
      }
      getTraceTimeToLive_result result = new getTraceTimeToLive_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.qe != null) {
        throw result.qe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTraceTimeToLive failed: unknown result");
    }

    public int getDataTimeToLive() throws QueryException, TException
    {
      send_getDataTimeToLive();
      return recv_getDataTimeToLive();
    }

    public void send_getDataTimeToLive() throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getDataTimeToLive", TMessageType.CALL, ++seqid_));
      getDataTimeToLive_args args = new getDataTimeToLive_args();
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public int recv_getDataTimeToLive() throws QueryException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getDataTimeToLive failed: out of sequence response");
      }
      getDataTimeToLive_result result = new getDataTimeToLive_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.qe != null) {
        throw result.qe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getDataTimeToLive failed: unknown result");
    }

    public List<String> getDependencies(String service_name) throws QueryException, TException
    {
      send_getDependencies(service_name);
      return recv_getDependencies();
    }

    public void send_getDependencies(String service_name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getDependencies", TMessageType.CALL, ++seqid_));
      getDependencies_args args = new getDependencies_args();
      args.setService_name(service_name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_getDependencies() throws QueryException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getDependencies failed: out of sequence response");
      }
      getDependencies_result result = new getDependencies_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.qe != null) {
        throw result.qe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getDependencies failed: unknown result");
    }

    public List<String> getTopAnnotations(String service_name) throws QueryException, TException
    {
      send_getTopAnnotations(service_name);
      return recv_getTopAnnotations();
    }

    public void send_getTopAnnotations(String service_name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getTopAnnotations", TMessageType.CALL, ++seqid_));
      getTopAnnotations_args args = new getTopAnnotations_args();
      args.setService_name(service_name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_getTopAnnotations() throws QueryException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getTopAnnotations failed: out of sequence response");
      }
      getTopAnnotations_result result = new getTopAnnotations_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.qe != null) {
        throw result.qe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTopAnnotations failed: unknown result");
    }

    public List<String> getTopKeyValueAnnotations(String service_name) throws QueryException, TException
    {
      send_getTopKeyValueAnnotations(service_name);
      return recv_getTopKeyValueAnnotations();
    }

    public void send_getTopKeyValueAnnotations(String service_name) throws TException
    {
      oprot_.writeMessageBegin(new TMessage("getTopKeyValueAnnotations", TMessageType.CALL, ++seqid_));
      getTopKeyValueAnnotations_args args = new getTopKeyValueAnnotations_args();
      args.setService_name(service_name);
      args.write(oprot_);
      oprot_.writeMessageEnd();
      oprot_.getTransport().flush();
    }

    public List<String> recv_getTopKeyValueAnnotations() throws QueryException, TException
    {
      TMessage msg = iprot_.readMessageBegin();
      if (msg.type == TMessageType.EXCEPTION) {
        TApplicationException x = TApplicationException.read(iprot_);
        iprot_.readMessageEnd();
        throw x;
      }
      if (msg.seqid != seqid_) {
        throw new TApplicationException(TApplicationException.BAD_SEQUENCE_ID, "getTopKeyValueAnnotations failed: out of sequence response");
      }
      getTopKeyValueAnnotations_result result = new getTopKeyValueAnnotations_result();
      result.read(iprot_);
      iprot_.readMessageEnd();
      if (result.isSetSuccess()) {
        return result.success;
      }
      if (result.qe != null) {
        throw result.qe;
      }
      throw new TApplicationException(TApplicationException.MISSING_RESULT, "getTopKeyValueAnnotations failed: unknown result");
    }

  }
  public static class AsyncClient extends TAsyncClient implements AsyncIface {
    public static class Factory implements TAsyncClientFactory<AsyncClient> {
      private TAsyncClientManager clientManager;
      private TProtocolFactory protocolFactory;
      public Factory(TAsyncClientManager clientManager, TProtocolFactory protocolFactory) {
        this.clientManager = clientManager;
        this.protocolFactory = protocolFactory;
      }
      public AsyncClient getAsyncClient(TNonblockingTransport transport) {
        return new AsyncClient(protocolFactory, clientManager, transport);
      }
    }

    public AsyncClient(TProtocolFactory protocolFactory, TAsyncClientManager clientManager, TNonblockingTransport transport) {
      super(protocolFactory, clientManager, transport);
    }

    public void getTraceIds(QueryRequest request, AsyncMethodCallback<getTraceIds_call> resultHandler) throws TException {
      checkReady();
      getTraceIds_call method_call = new getTraceIds_call(request, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getTraceIds_call extends TAsyncMethodCall {
      private QueryRequest request;
      public getTraceIds_call(QueryRequest request, AsyncMethodCallback<getTraceIds_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.request = request;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTraceIds", TMessageType.CALL, 0));
        getTraceIds_args args = new getTraceIds_args();
        args.setRequest(request);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public QueryResponse getResult() throws QueryException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTraceIds();
      }
    }

    public void getTraceIdsBySpanName(String service_name, String span_name, long end_ts, int limit, Order order, AsyncMethodCallback<getTraceIdsBySpanName_call> resultHandler) throws TException {
      checkReady();
      getTraceIdsBySpanName_call method_call = new getTraceIdsBySpanName_call(service_name, span_name, end_ts, limit, order, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getTraceIdsBySpanName_call extends TAsyncMethodCall {
      private String service_name;
      private String span_name;
      private long end_ts;
      private int limit;
      private Order order;
      public getTraceIdsBySpanName_call(String service_name, String span_name, long end_ts, int limit, Order order, AsyncMethodCallback<getTraceIdsBySpanName_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.service_name = service_name;
        this.span_name = span_name;
        this.end_ts = end_ts;
        this.limit = limit;
        this.order = order;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTraceIdsBySpanName", TMessageType.CALL, 0));
        getTraceIdsBySpanName_args args = new getTraceIdsBySpanName_args();
        args.setService_name(service_name);
        args.setSpan_name(span_name);
        args.setEnd_ts(end_ts);
        args.setLimit(limit);
        args.setOrder(order);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<Long> getResult() throws QueryException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTraceIdsBySpanName();
      }
    }

    public void getTraceIdsByServiceName(String service_name, long end_ts, int limit, Order order, AsyncMethodCallback<getTraceIdsByServiceName_call> resultHandler) throws TException {
      checkReady();
      getTraceIdsByServiceName_call method_call = new getTraceIdsByServiceName_call(service_name, end_ts, limit, order, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getTraceIdsByServiceName_call extends TAsyncMethodCall {
      private String service_name;
      private long end_ts;
      private int limit;
      private Order order;
      public getTraceIdsByServiceName_call(String service_name, long end_ts, int limit, Order order, AsyncMethodCallback<getTraceIdsByServiceName_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.service_name = service_name;
        this.end_ts = end_ts;
        this.limit = limit;
        this.order = order;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTraceIdsByServiceName", TMessageType.CALL, 0));
        getTraceIdsByServiceName_args args = new getTraceIdsByServiceName_args();
        args.setService_name(service_name);
        args.setEnd_ts(end_ts);
        args.setLimit(limit);
        args.setOrder(order);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<Long> getResult() throws QueryException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTraceIdsByServiceName();
      }
    }

    public void getTraceIdsByAnnotation(String service_name, String annotation, ByteBuffer value, long end_ts, int limit, Order order, AsyncMethodCallback<getTraceIdsByAnnotation_call> resultHandler) throws TException {
      checkReady();
      getTraceIdsByAnnotation_call method_call = new getTraceIdsByAnnotation_call(service_name, annotation, value, end_ts, limit, order, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getTraceIdsByAnnotation_call extends TAsyncMethodCall {
      private String service_name;
      private String annotation;
      private ByteBuffer value;
      private long end_ts;
      private int limit;
      private Order order;
      public getTraceIdsByAnnotation_call(String service_name, String annotation, ByteBuffer value, long end_ts, int limit, Order order, AsyncMethodCallback<getTraceIdsByAnnotation_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.service_name = service_name;
        this.annotation = annotation;
        this.value = value;
        this.end_ts = end_ts;
        this.limit = limit;
        this.order = order;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTraceIdsByAnnotation", TMessageType.CALL, 0));
        getTraceIdsByAnnotation_args args = new getTraceIdsByAnnotation_args();
        args.setService_name(service_name);
        args.setAnnotation(annotation);
        args.setValue(value);
        args.setEnd_ts(end_ts);
        args.setLimit(limit);
        args.setOrder(order);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<Long> getResult() throws QueryException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTraceIdsByAnnotation();
      }
    }

    public void tracesExist(List<Long> trace_ids, AsyncMethodCallback<tracesExist_call> resultHandler) throws TException {
      checkReady();
      tracesExist_call method_call = new tracesExist_call(trace_ids, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class tracesExist_call extends TAsyncMethodCall {
      private List<Long> trace_ids;
      public tracesExist_call(List<Long> trace_ids, AsyncMethodCallback<tracesExist_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.trace_ids = trace_ids;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("tracesExist", TMessageType.CALL, 0));
        tracesExist_args args = new tracesExist_args();
        args.setTrace_ids(trace_ids);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Set<Long> getResult() throws QueryException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_tracesExist();
      }
    }

    public void getTracesByIds(List<Long> trace_ids, List<Adjust> adjust, AsyncMethodCallback<getTracesByIds_call> resultHandler) throws TException {
      checkReady();
      getTracesByIds_call method_call = new getTracesByIds_call(trace_ids, adjust, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getTracesByIds_call extends TAsyncMethodCall {
      private List<Long> trace_ids;
      private List<Adjust> adjust;
      public getTracesByIds_call(List<Long> trace_ids, List<Adjust> adjust, AsyncMethodCallback<getTracesByIds_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.trace_ids = trace_ids;
        this.adjust = adjust;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTracesByIds", TMessageType.CALL, 0));
        getTracesByIds_args args = new getTracesByIds_args();
        args.setTrace_ids(trace_ids);
        args.setAdjust(adjust);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<Trace> getResult() throws QueryException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTracesByIds();
      }
    }

    public void getTraceTimelinesByIds(List<Long> trace_ids, List<Adjust> adjust, AsyncMethodCallback<getTraceTimelinesByIds_call> resultHandler) throws TException {
      checkReady();
      getTraceTimelinesByIds_call method_call = new getTraceTimelinesByIds_call(trace_ids, adjust, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getTraceTimelinesByIds_call extends TAsyncMethodCall {
      private List<Long> trace_ids;
      private List<Adjust> adjust;
      public getTraceTimelinesByIds_call(List<Long> trace_ids, List<Adjust> adjust, AsyncMethodCallback<getTraceTimelinesByIds_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.trace_ids = trace_ids;
        this.adjust = adjust;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTraceTimelinesByIds", TMessageType.CALL, 0));
        getTraceTimelinesByIds_args args = new getTraceTimelinesByIds_args();
        args.setTrace_ids(trace_ids);
        args.setAdjust(adjust);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<TraceTimeline> getResult() throws QueryException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTraceTimelinesByIds();
      }
    }

    public void getTraceSummariesByIds(List<Long> trace_ids, List<Adjust> adjust, AsyncMethodCallback<getTraceSummariesByIds_call> resultHandler) throws TException {
      checkReady();
      getTraceSummariesByIds_call method_call = new getTraceSummariesByIds_call(trace_ids, adjust, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getTraceSummariesByIds_call extends TAsyncMethodCall {
      private List<Long> trace_ids;
      private List<Adjust> adjust;
      public getTraceSummariesByIds_call(List<Long> trace_ids, List<Adjust> adjust, AsyncMethodCallback<getTraceSummariesByIds_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.trace_ids = trace_ids;
        this.adjust = adjust;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTraceSummariesByIds", TMessageType.CALL, 0));
        getTraceSummariesByIds_args args = new getTraceSummariesByIds_args();
        args.setTrace_ids(trace_ids);
        args.setAdjust(adjust);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<TraceSummary> getResult() throws QueryException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTraceSummariesByIds();
      }
    }

    public void getTraceCombosByIds(List<Long> trace_ids, List<Adjust> adjust, AsyncMethodCallback<getTraceCombosByIds_call> resultHandler) throws TException {
      checkReady();
      getTraceCombosByIds_call method_call = new getTraceCombosByIds_call(trace_ids, adjust, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getTraceCombosByIds_call extends TAsyncMethodCall {
      private List<Long> trace_ids;
      private List<Adjust> adjust;
      public getTraceCombosByIds_call(List<Long> trace_ids, List<Adjust> adjust, AsyncMethodCallback<getTraceCombosByIds_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.trace_ids = trace_ids;
        this.adjust = adjust;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTraceCombosByIds", TMessageType.CALL, 0));
        getTraceCombosByIds_args args = new getTraceCombosByIds_args();
        args.setTrace_ids(trace_ids);
        args.setAdjust(adjust);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<TraceCombo> getResult() throws QueryException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTraceCombosByIds();
      }
    }

    public void getServiceNames(AsyncMethodCallback<getServiceNames_call> resultHandler) throws TException {
      checkReady();
      getServiceNames_call method_call = new getServiceNames_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getServiceNames_call extends TAsyncMethodCall {
      public getServiceNames_call(AsyncMethodCallback<getServiceNames_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getServiceNames", TMessageType.CALL, 0));
        getServiceNames_args args = new getServiceNames_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Set<String> getResult() throws QueryException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getServiceNames();
      }
    }

    public void getSpanNames(String service_name, AsyncMethodCallback<getSpanNames_call> resultHandler) throws TException {
      checkReady();
      getSpanNames_call method_call = new getSpanNames_call(service_name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getSpanNames_call extends TAsyncMethodCall {
      private String service_name;
      public getSpanNames_call(String service_name, AsyncMethodCallback<getSpanNames_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.service_name = service_name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getSpanNames", TMessageType.CALL, 0));
        getSpanNames_args args = new getSpanNames_args();
        args.setService_name(service_name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public Set<String> getResult() throws QueryException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getSpanNames();
      }
    }

    public void setTraceTimeToLive(long trace_id, int ttl_seconds, AsyncMethodCallback<setTraceTimeToLive_call> resultHandler) throws TException {
      checkReady();
      setTraceTimeToLive_call method_call = new setTraceTimeToLive_call(trace_id, ttl_seconds, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class setTraceTimeToLive_call extends TAsyncMethodCall {
      private long trace_id;
      private int ttl_seconds;
      public setTraceTimeToLive_call(long trace_id, int ttl_seconds, AsyncMethodCallback<setTraceTimeToLive_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.trace_id = trace_id;
        this.ttl_seconds = ttl_seconds;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("setTraceTimeToLive", TMessageType.CALL, 0));
        setTraceTimeToLive_args args = new setTraceTimeToLive_args();
        args.setTrace_id(trace_id);
        args.setTtl_seconds(ttl_seconds);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public void getResult() throws QueryException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        (new Client(prot)).recv_setTraceTimeToLive();
      }
    }

    public void getTraceTimeToLive(long trace_id, AsyncMethodCallback<getTraceTimeToLive_call> resultHandler) throws TException {
      checkReady();
      getTraceTimeToLive_call method_call = new getTraceTimeToLive_call(trace_id, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getTraceTimeToLive_call extends TAsyncMethodCall {
      private long trace_id;
      public getTraceTimeToLive_call(long trace_id, AsyncMethodCallback<getTraceTimeToLive_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.trace_id = trace_id;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTraceTimeToLive", TMessageType.CALL, 0));
        getTraceTimeToLive_args args = new getTraceTimeToLive_args();
        args.setTrace_id(trace_id);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public int getResult() throws QueryException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTraceTimeToLive();
      }
    }

    public void getDataTimeToLive(AsyncMethodCallback<getDataTimeToLive_call> resultHandler) throws TException {
      checkReady();
      getDataTimeToLive_call method_call = new getDataTimeToLive_call(resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getDataTimeToLive_call extends TAsyncMethodCall {
      public getDataTimeToLive_call(AsyncMethodCallback<getDataTimeToLive_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getDataTimeToLive", TMessageType.CALL, 0));
        getDataTimeToLive_args args = new getDataTimeToLive_args();
        args.write(prot);
        prot.writeMessageEnd();
      }

      public int getResult() throws QueryException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getDataTimeToLive();
      }
    }

    public void getDependencies(String service_name, AsyncMethodCallback<getDependencies_call> resultHandler) throws TException {
      checkReady();
      getDependencies_call method_call = new getDependencies_call(service_name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getDependencies_call extends TAsyncMethodCall {
      private String service_name;
      public getDependencies_call(String service_name, AsyncMethodCallback<getDependencies_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.service_name = service_name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getDependencies", TMessageType.CALL, 0));
        getDependencies_args args = new getDependencies_args();
        args.setService_name(service_name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<String> getResult() throws QueryException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getDependencies();
      }
    }

    public void getTopAnnotations(String service_name, AsyncMethodCallback<getTopAnnotations_call> resultHandler) throws TException {
      checkReady();
      getTopAnnotations_call method_call = new getTopAnnotations_call(service_name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getTopAnnotations_call extends TAsyncMethodCall {
      private String service_name;
      public getTopAnnotations_call(String service_name, AsyncMethodCallback<getTopAnnotations_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.service_name = service_name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTopAnnotations", TMessageType.CALL, 0));
        getTopAnnotations_args args = new getTopAnnotations_args();
        args.setService_name(service_name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<String> getResult() throws QueryException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTopAnnotations();
      }
    }

    public void getTopKeyValueAnnotations(String service_name, AsyncMethodCallback<getTopKeyValueAnnotations_call> resultHandler) throws TException {
      checkReady();
      getTopKeyValueAnnotations_call method_call = new getTopKeyValueAnnotations_call(service_name, resultHandler, this, protocolFactory, transport);
      manager.call(method_call);
    }

    public static class getTopKeyValueAnnotations_call extends TAsyncMethodCall {
      private String service_name;
      public getTopKeyValueAnnotations_call(String service_name, AsyncMethodCallback<getTopKeyValueAnnotations_call> resultHandler, TAsyncClient client, TProtocolFactory protocolFactory, TNonblockingTransport transport) throws TException {
        super(client, protocolFactory, transport, resultHandler, false);
        this.service_name = service_name;
      }

      public void write_args(TProtocol prot) throws TException {
        prot.writeMessageBegin(new TMessage("getTopKeyValueAnnotations", TMessageType.CALL, 0));
        getTopKeyValueAnnotations_args args = new getTopKeyValueAnnotations_args();
        args.setService_name(service_name);
        args.write(prot);
        prot.writeMessageEnd();
      }

      public List<String> getResult() throws QueryException, TException {
        if (getState() != State.RESPONSE_READ) {
          throw new IllegalStateException("Method call not finished!");
        }
        TMemoryInputTransport memoryTransport = new TMemoryInputTransport(getFrameBuffer().array());
        TProtocol prot = client.getProtocolFactory().getProtocol(memoryTransport);
        return (new Client(prot)).recv_getTopKeyValueAnnotations();
      }
    }

  }

  public static class Processor implements TProcessor {
    private static final Logger LOGGER = LoggerFactory.getLogger(Processor.class.getName());
    public Processor(Iface iface)
    {
      iface_ = iface;
      processMap_.put("getTraceIds", new getTraceIds());
      processMap_.put("getTraceIdsBySpanName", new getTraceIdsBySpanName());
      processMap_.put("getTraceIdsByServiceName", new getTraceIdsByServiceName());
      processMap_.put("getTraceIdsByAnnotation", new getTraceIdsByAnnotation());
      processMap_.put("tracesExist", new tracesExist());
      processMap_.put("getTracesByIds", new getTracesByIds());
      processMap_.put("getTraceTimelinesByIds", new getTraceTimelinesByIds());
      processMap_.put("getTraceSummariesByIds", new getTraceSummariesByIds());
      processMap_.put("getTraceCombosByIds", new getTraceCombosByIds());
      processMap_.put("getServiceNames", new getServiceNames());
      processMap_.put("getSpanNames", new getSpanNames());
      processMap_.put("setTraceTimeToLive", new setTraceTimeToLive());
      processMap_.put("getTraceTimeToLive", new getTraceTimeToLive());
      processMap_.put("getDataTimeToLive", new getDataTimeToLive());
      processMap_.put("getDependencies", new getDependencies());
      processMap_.put("getTopAnnotations", new getTopAnnotations());
      processMap_.put("getTopKeyValueAnnotations", new getTopKeyValueAnnotations());
    }

    protected static interface ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException;
    }

    private Iface iface_;
    protected final HashMap<String,ProcessFunction> processMap_ = new HashMap<String,ProcessFunction>();

    public boolean process(TProtocol iprot, TProtocol oprot) throws TException
    {
      TMessage msg = iprot.readMessageBegin();
      ProcessFunction fn = processMap_.get(msg.name);
      if (fn == null) {
        TProtocolUtil.skip(iprot, TType.STRUCT);
        iprot.readMessageEnd();
        TApplicationException x = new TApplicationException(TApplicationException.UNKNOWN_METHOD, "Invalid method name: '"+msg.name+"'");
        oprot.writeMessageBegin(new TMessage(msg.name, TMessageType.EXCEPTION, msg.seqid));
        x.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
        return true;
      }
      fn.process(msg.seqid, iprot, oprot);
      return true;
    }

    private class getTraceIds implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getTraceIds_args args = new getTraceIds_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getTraceIds", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getTraceIds_result result = new getTraceIds_result();
        try {
          result.success = iface_.getTraceIds(args.request);
        } catch (QueryException qe) {
          result.qe = qe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getTraceIds", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getTraceIds");
          oprot.writeMessageBegin(new TMessage("getTraceIds", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getTraceIds", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getTraceIdsBySpanName implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getTraceIdsBySpanName_args args = new getTraceIdsBySpanName_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getTraceIdsBySpanName", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getTraceIdsBySpanName_result result = new getTraceIdsBySpanName_result();
        try {
          result.success = iface_.getTraceIdsBySpanName(args.service_name, args.span_name, args.end_ts, args.limit, args.order);
        } catch (QueryException qe) {
          result.qe = qe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getTraceIdsBySpanName", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getTraceIdsBySpanName");
          oprot.writeMessageBegin(new TMessage("getTraceIdsBySpanName", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getTraceIdsBySpanName", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getTraceIdsByServiceName implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getTraceIdsByServiceName_args args = new getTraceIdsByServiceName_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getTraceIdsByServiceName", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getTraceIdsByServiceName_result result = new getTraceIdsByServiceName_result();
        try {
          result.success = iface_.getTraceIdsByServiceName(args.service_name, args.end_ts, args.limit, args.order);
        } catch (QueryException qe) {
          result.qe = qe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getTraceIdsByServiceName", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getTraceIdsByServiceName");
          oprot.writeMessageBegin(new TMessage("getTraceIdsByServiceName", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getTraceIdsByServiceName", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getTraceIdsByAnnotation implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getTraceIdsByAnnotation_args args = new getTraceIdsByAnnotation_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getTraceIdsByAnnotation", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getTraceIdsByAnnotation_result result = new getTraceIdsByAnnotation_result();
        try {
          result.success = iface_.getTraceIdsByAnnotation(args.service_name, args.annotation, args.value, args.end_ts, args.limit, args.order);
        } catch (QueryException qe) {
          result.qe = qe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getTraceIdsByAnnotation", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getTraceIdsByAnnotation");
          oprot.writeMessageBegin(new TMessage("getTraceIdsByAnnotation", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getTraceIdsByAnnotation", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class tracesExist implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        tracesExist_args args = new tracesExist_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("tracesExist", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        tracesExist_result result = new tracesExist_result();
        try {
          result.success = iface_.tracesExist(args.trace_ids);
        } catch (QueryException qe) {
          result.qe = qe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing tracesExist", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing tracesExist");
          oprot.writeMessageBegin(new TMessage("tracesExist", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("tracesExist", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getTracesByIds implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getTracesByIds_args args = new getTracesByIds_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getTracesByIds", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getTracesByIds_result result = new getTracesByIds_result();
        try {
          result.success = iface_.getTracesByIds(args.trace_ids, args.adjust);
        } catch (QueryException qe) {
          result.qe = qe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getTracesByIds", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getTracesByIds");
          oprot.writeMessageBegin(new TMessage("getTracesByIds", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getTracesByIds", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getTraceTimelinesByIds implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getTraceTimelinesByIds_args args = new getTraceTimelinesByIds_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getTraceTimelinesByIds", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getTraceTimelinesByIds_result result = new getTraceTimelinesByIds_result();
        try {
          result.success = iface_.getTraceTimelinesByIds(args.trace_ids, args.adjust);
        } catch (QueryException qe) {
          result.qe = qe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getTraceTimelinesByIds", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getTraceTimelinesByIds");
          oprot.writeMessageBegin(new TMessage("getTraceTimelinesByIds", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getTraceTimelinesByIds", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getTraceSummariesByIds implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getTraceSummariesByIds_args args = new getTraceSummariesByIds_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getTraceSummariesByIds", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getTraceSummariesByIds_result result = new getTraceSummariesByIds_result();
        try {
          result.success = iface_.getTraceSummariesByIds(args.trace_ids, args.adjust);
        } catch (QueryException qe) {
          result.qe = qe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getTraceSummariesByIds", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getTraceSummariesByIds");
          oprot.writeMessageBegin(new TMessage("getTraceSummariesByIds", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getTraceSummariesByIds", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getTraceCombosByIds implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getTraceCombosByIds_args args = new getTraceCombosByIds_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getTraceCombosByIds", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getTraceCombosByIds_result result = new getTraceCombosByIds_result();
        try {
          result.success = iface_.getTraceCombosByIds(args.trace_ids, args.adjust);
        } catch (QueryException qe) {
          result.qe = qe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getTraceCombosByIds", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getTraceCombosByIds");
          oprot.writeMessageBegin(new TMessage("getTraceCombosByIds", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getTraceCombosByIds", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getServiceNames implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getServiceNames_args args = new getServiceNames_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getServiceNames", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getServiceNames_result result = new getServiceNames_result();
        try {
          result.success = iface_.getServiceNames();
        } catch (QueryException qe) {
          result.qe = qe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getServiceNames", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getServiceNames");
          oprot.writeMessageBegin(new TMessage("getServiceNames", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getServiceNames", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getSpanNames implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getSpanNames_args args = new getSpanNames_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getSpanNames", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getSpanNames_result result = new getSpanNames_result();
        try {
          result.success = iface_.getSpanNames(args.service_name);
        } catch (QueryException qe) {
          result.qe = qe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getSpanNames", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getSpanNames");
          oprot.writeMessageBegin(new TMessage("getSpanNames", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getSpanNames", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class setTraceTimeToLive implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        setTraceTimeToLive_args args = new setTraceTimeToLive_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("setTraceTimeToLive", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        setTraceTimeToLive_result result = new setTraceTimeToLive_result();
        try {
          iface_.setTraceTimeToLive(args.trace_id, args.ttl_seconds);
        } catch (QueryException qe) {
          result.qe = qe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing setTraceTimeToLive", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing setTraceTimeToLive");
          oprot.writeMessageBegin(new TMessage("setTraceTimeToLive", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("setTraceTimeToLive", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getTraceTimeToLive implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getTraceTimeToLive_args args = new getTraceTimeToLive_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getTraceTimeToLive", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getTraceTimeToLive_result result = new getTraceTimeToLive_result();
        try {
          result.success = iface_.getTraceTimeToLive(args.trace_id);
          result.setSuccessIsSet(true);
        } catch (QueryException qe) {
          result.qe = qe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getTraceTimeToLive", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getTraceTimeToLive");
          oprot.writeMessageBegin(new TMessage("getTraceTimeToLive", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getTraceTimeToLive", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getDataTimeToLive implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getDataTimeToLive_args args = new getDataTimeToLive_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getDataTimeToLive", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getDataTimeToLive_result result = new getDataTimeToLive_result();
        try {
          result.success = iface_.getDataTimeToLive();
          result.setSuccessIsSet(true);
        } catch (QueryException qe) {
          result.qe = qe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getDataTimeToLive", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getDataTimeToLive");
          oprot.writeMessageBegin(new TMessage("getDataTimeToLive", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getDataTimeToLive", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getDependencies implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getDependencies_args args = new getDependencies_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getDependencies", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getDependencies_result result = new getDependencies_result();
        try {
          result.success = iface_.getDependencies(args.service_name);
        } catch (QueryException qe) {
          result.qe = qe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getDependencies", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getDependencies");
          oprot.writeMessageBegin(new TMessage("getDependencies", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getDependencies", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getTopAnnotations implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getTopAnnotations_args args = new getTopAnnotations_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getTopAnnotations", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getTopAnnotations_result result = new getTopAnnotations_result();
        try {
          result.success = iface_.getTopAnnotations(args.service_name);
        } catch (QueryException qe) {
          result.qe = qe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getTopAnnotations", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getTopAnnotations");
          oprot.writeMessageBegin(new TMessage("getTopAnnotations", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getTopAnnotations", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

    private class getTopKeyValueAnnotations implements ProcessFunction {
      public void process(int seqid, TProtocol iprot, TProtocol oprot) throws TException
      {
        getTopKeyValueAnnotations_args args = new getTopKeyValueAnnotations_args();
        try {
          args.read(iprot);
        } catch (TProtocolException e) {
          iprot.readMessageEnd();
          TApplicationException x = new TApplicationException(TApplicationException.PROTOCOL_ERROR, e.getMessage());
          oprot.writeMessageBegin(new TMessage("getTopKeyValueAnnotations", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        iprot.readMessageEnd();
        getTopKeyValueAnnotations_result result = new getTopKeyValueAnnotations_result();
        try {
          result.success = iface_.getTopKeyValueAnnotations(args.service_name);
        } catch (QueryException qe) {
          result.qe = qe;
        } catch (Throwable th) {
          LOGGER.error("Internal error processing getTopKeyValueAnnotations", th);
          TApplicationException x = new TApplicationException(TApplicationException.INTERNAL_ERROR, "Internal error processing getTopKeyValueAnnotations");
          oprot.writeMessageBegin(new TMessage("getTopKeyValueAnnotations", TMessageType.EXCEPTION, seqid));
          x.write(oprot);
          oprot.writeMessageEnd();
          oprot.getTransport().flush();
          return;
        }
        oprot.writeMessageBegin(new TMessage("getTopKeyValueAnnotations", TMessageType.REPLY, seqid));
        result.write(oprot);
        oprot.writeMessageEnd();
        oprot.getTransport().flush();
      }

    }

  }

  public static class getTraceIds_args implements TBase<getTraceIds_args, getTraceIds_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTraceIds_args");

    private static final TField REQUEST_FIELD_DESC = new TField("request", TType.STRUCT, (short)1);

    public QueryRequest request;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      REQUEST((short)1, "request");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // REQUEST
            return REQUEST;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.REQUEST, new FieldMetaData("request", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, QueryRequest.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTraceIds_args.class, metaDataMap);
    }

    public getTraceIds_args() {
    }

    public getTraceIds_args(
      QueryRequest request)
    {
      this();
      this.request = request;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTraceIds_args(getTraceIds_args other) {
      if (other.isSetRequest()) {
        this.request = new QueryRequest(other.request);
      }
    }

    public getTraceIds_args deepCopy() {
      return new getTraceIds_args(this);
    }

    @Override
    public void clear() {
      this.request = null;
    }

    public QueryRequest getRequest() {
      return this.request;
    }

    public getTraceIds_args setRequest(QueryRequest request) {
      this.request = request;
      return this;
    }

    public void unsetRequest() {
      this.request = null;
    }

    /** Returns true if field request is set (has been asigned a value) and false otherwise */
    public boolean isSetRequest() {
      return this.request != null;
    }

    public void setRequestIsSet(boolean value) {
      if (!value) {
        this.request = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case REQUEST:
        if (value == null) {
          unsetRequest();
        } else {
          setRequest((QueryRequest)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case REQUEST:
        return getRequest();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case REQUEST:
        return isSetRequest();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTraceIds_args)
        return this.equals((getTraceIds_args)that);
      return false;
    }

    public boolean equals(getTraceIds_args that) {
      if (that == null)
        return false;

      boolean this_present_request = true && this.isSetRequest();
      boolean that_present_request = true && that.isSetRequest();
      if (this_present_request || that_present_request) {
        if (!(this_present_request && that_present_request))
          return false;
        if (!this.request.equals(that.request))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTraceIds_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTraceIds_args typedOther = (getTraceIds_args)other;

      lastComparison = Boolean.valueOf(isSetRequest()).compareTo(typedOther.isSetRequest());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetRequest()) {
        lastComparison = TBaseHelper.compareTo(this.request, typedOther.request);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // REQUEST
            if (field.type == TType.STRUCT) {
              this.request = new QueryRequest();
              this.request.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.request != null) {
        oprot.writeFieldBegin(REQUEST_FIELD_DESC);
        this.request.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTraceIds_args(");
      boolean first = true;

      sb.append("request:");
      if (this.request == null) {
        sb.append("null");
      } else {
        sb.append(this.request);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTraceIds_result implements TBase<getTraceIds_result, getTraceIds_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTraceIds_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.STRUCT, (short)0);
    private static final TField QE_FIELD_DESC = new TField("qe", TType.STRUCT, (short)1);

    public QueryResponse success;
    public QueryException qe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      QE((short)1, "qe");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // QE
            return QE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new StructMetaData(TType.STRUCT, QueryResponse.class)));
      tmpMap.put(_Fields.QE, new FieldMetaData("qe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTraceIds_result.class, metaDataMap);
    }

    public getTraceIds_result() {
    }

    public getTraceIds_result(
      QueryResponse success,
      QueryException qe)
    {
      this();
      this.success = success;
      this.qe = qe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTraceIds_result(getTraceIds_result other) {
      if (other.isSetSuccess()) {
        this.success = new QueryResponse(other.success);
      }
      if (other.isSetQe()) {
        this.qe = new QueryException(other.qe);
      }
    }

    public getTraceIds_result deepCopy() {
      return new getTraceIds_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.qe = null;
    }

    public QueryResponse getSuccess() {
      return this.success;
    }

    public getTraceIds_result setSuccess(QueryResponse success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public QueryException getQe() {
      return this.qe;
    }

    public getTraceIds_result setQe(QueryException qe) {
      this.qe = qe;
      return this;
    }

    public void unsetQe() {
      this.qe = null;
    }

    /** Returns true if field qe is set (has been asigned a value) and false otherwise */
    public boolean isSetQe() {
      return this.qe != null;
    }

    public void setQeIsSet(boolean value) {
      if (!value) {
        this.qe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((QueryResponse)value);
        }
        break;

      case QE:
        if (value == null) {
          unsetQe();
        } else {
          setQe((QueryException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case QE:
        return getQe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case QE:
        return isSetQe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTraceIds_result)
        return this.equals((getTraceIds_result)that);
      return false;
    }

    public boolean equals(getTraceIds_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_qe = true && this.isSetQe();
      boolean that_present_qe = true && that.isSetQe();
      if (this_present_qe || that_present_qe) {
        if (!(this_present_qe && that_present_qe))
          return false;
        if (!this.qe.equals(that.qe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTraceIds_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTraceIds_result typedOther = (getTraceIds_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetQe()).compareTo(typedOther.isSetQe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQe()) {
        lastComparison = TBaseHelper.compareTo(this.qe, typedOther.qe);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.STRUCT) {
              this.success = new QueryResponse();
              this.success.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // QE
            if (field.type == TType.STRUCT) {
              this.qe = new QueryException();
              this.qe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        this.success.write(oprot);
        oprot.writeFieldEnd();
      } else if (this.isSetQe()) {
        oprot.writeFieldBegin(QE_FIELD_DESC);
        this.qe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTraceIds_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("qe:");
      if (this.qe == null) {
        sb.append("null");
      } else {
        sb.append(this.qe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTraceIdsBySpanName_args implements TBase<getTraceIdsBySpanName_args, getTraceIdsBySpanName_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTraceIdsBySpanName_args");

    private static final TField SERVICE_NAME_FIELD_DESC = new TField("service_name", TType.STRING, (short)1);
    private static final TField SPAN_NAME_FIELD_DESC = new TField("span_name", TType.STRING, (short)2);
    private static final TField END_TS_FIELD_DESC = new TField("end_ts", TType.I64, (short)4);
    private static final TField LIMIT_FIELD_DESC = new TField("limit", TType.I32, (short)5);
    private static final TField ORDER_FIELD_DESC = new TField("order", TType.I32, (short)6);

    public String service_name;
    public String span_name;
    public long end_ts;
    public int limit;
    /**
     * 
     * @see Order
     */
    public Order order;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SERVICE_NAME((short)1, "service_name"),
      SPAN_NAME((short)2, "span_name"),
      END_TS((short)4, "end_ts"),
      LIMIT((short)5, "limit"),
      /**
       * 
       * @see Order
       */
      ORDER((short)6, "order");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SERVICE_NAME
            return SERVICE_NAME;
          case 2: // SPAN_NAME
            return SPAN_NAME;
          case 4: // END_TS
            return END_TS;
          case 5: // LIMIT
            return LIMIT;
          case 6: // ORDER
            return ORDER;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __END_TS_ISSET_ID = 0;
    private static final int __LIMIT_ISSET_ID = 1;
    private BitSet __isset_bit_vector = new BitSet(2);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SERVICE_NAME, new FieldMetaData("service_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.SPAN_NAME, new FieldMetaData("span_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.END_TS, new FieldMetaData("end_ts", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      tmpMap.put(_Fields.LIMIT, new FieldMetaData("limit", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      tmpMap.put(_Fields.ORDER, new FieldMetaData("order", TFieldRequirementType.DEFAULT, 
          new EnumMetaData(TType.ENUM, Order.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTraceIdsBySpanName_args.class, metaDataMap);
    }

    public getTraceIdsBySpanName_args() {
    }

    public getTraceIdsBySpanName_args(
      String service_name,
      String span_name,
      long end_ts,
      int limit,
      Order order)
    {
      this();
      this.service_name = service_name;
      this.span_name = span_name;
      this.end_ts = end_ts;
      setEnd_tsIsSet(true);
      this.limit = limit;
      setLimitIsSet(true);
      this.order = order;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTraceIdsBySpanName_args(getTraceIdsBySpanName_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetService_name()) {
        this.service_name = other.service_name;
      }
      if (other.isSetSpan_name()) {
        this.span_name = other.span_name;
      }
      this.end_ts = other.end_ts;
      this.limit = other.limit;
      if (other.isSetOrder()) {
        this.order = other.order;
      }
    }

    public getTraceIdsBySpanName_args deepCopy() {
      return new getTraceIdsBySpanName_args(this);
    }

    @Override
    public void clear() {
      this.service_name = null;
      this.span_name = null;
      setEnd_tsIsSet(false);
      this.end_ts = 0;
      setLimitIsSet(false);
      this.limit = 0;
      this.order = null;
    }

    public String getService_name() {
      return this.service_name;
    }

    public getTraceIdsBySpanName_args setService_name(String service_name) {
      this.service_name = service_name;
      return this;
    }

    public void unsetService_name() {
      this.service_name = null;
    }

    /** Returns true if field service_name is set (has been asigned a value) and false otherwise */
    public boolean isSetService_name() {
      return this.service_name != null;
    }

    public void setService_nameIsSet(boolean value) {
      if (!value) {
        this.service_name = null;
      }
    }

    public String getSpan_name() {
      return this.span_name;
    }

    public getTraceIdsBySpanName_args setSpan_name(String span_name) {
      this.span_name = span_name;
      return this;
    }

    public void unsetSpan_name() {
      this.span_name = null;
    }

    /** Returns true if field span_name is set (has been asigned a value) and false otherwise */
    public boolean isSetSpan_name() {
      return this.span_name != null;
    }

    public void setSpan_nameIsSet(boolean value) {
      if (!value) {
        this.span_name = null;
      }
    }

    public long getEnd_ts() {
      return this.end_ts;
    }

    public getTraceIdsBySpanName_args setEnd_ts(long end_ts) {
      this.end_ts = end_ts;
      setEnd_tsIsSet(true);
      return this;
    }

    public void unsetEnd_ts() {
      __isset_bit_vector.clear(__END_TS_ISSET_ID);
    }

    /** Returns true if field end_ts is set (has been asigned a value) and false otherwise */
    public boolean isSetEnd_ts() {
      return __isset_bit_vector.get(__END_TS_ISSET_ID);
    }

    public void setEnd_tsIsSet(boolean value) {
      __isset_bit_vector.set(__END_TS_ISSET_ID, value);
    }

    public int getLimit() {
      return this.limit;
    }

    public getTraceIdsBySpanName_args setLimit(int limit) {
      this.limit = limit;
      setLimitIsSet(true);
      return this;
    }

    public void unsetLimit() {
      __isset_bit_vector.clear(__LIMIT_ISSET_ID);
    }

    /** Returns true if field limit is set (has been asigned a value) and false otherwise */
    public boolean isSetLimit() {
      return __isset_bit_vector.get(__LIMIT_ISSET_ID);
    }

    public void setLimitIsSet(boolean value) {
      __isset_bit_vector.set(__LIMIT_ISSET_ID, value);
    }

    /**
     * 
     * @see Order
     */
    public Order getOrder() {
      return this.order;
    }

    /**
     * 
     * @see Order
     */
    public getTraceIdsBySpanName_args setOrder(Order order) {
      this.order = order;
      return this;
    }

    public void unsetOrder() {
      this.order = null;
    }

    /** Returns true if field order is set (has been asigned a value) and false otherwise */
    public boolean isSetOrder() {
      return this.order != null;
    }

    public void setOrderIsSet(boolean value) {
      if (!value) {
        this.order = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SERVICE_NAME:
        if (value == null) {
          unsetService_name();
        } else {
          setService_name((String)value);
        }
        break;

      case SPAN_NAME:
        if (value == null) {
          unsetSpan_name();
        } else {
          setSpan_name((String)value);
        }
        break;

      case END_TS:
        if (value == null) {
          unsetEnd_ts();
        } else {
          setEnd_ts((Long)value);
        }
        break;

      case LIMIT:
        if (value == null) {
          unsetLimit();
        } else {
          setLimit((Integer)value);
        }
        break;

      case ORDER:
        if (value == null) {
          unsetOrder();
        } else {
          setOrder((Order)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SERVICE_NAME:
        return getService_name();

      case SPAN_NAME:
        return getSpan_name();

      case END_TS:
        return new Long(getEnd_ts());

      case LIMIT:
        return new Integer(getLimit());

      case ORDER:
        return getOrder();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SERVICE_NAME:
        return isSetService_name();
      case SPAN_NAME:
        return isSetSpan_name();
      case END_TS:
        return isSetEnd_ts();
      case LIMIT:
        return isSetLimit();
      case ORDER:
        return isSetOrder();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTraceIdsBySpanName_args)
        return this.equals((getTraceIdsBySpanName_args)that);
      return false;
    }

    public boolean equals(getTraceIdsBySpanName_args that) {
      if (that == null)
        return false;

      boolean this_present_service_name = true && this.isSetService_name();
      boolean that_present_service_name = true && that.isSetService_name();
      if (this_present_service_name || that_present_service_name) {
        if (!(this_present_service_name && that_present_service_name))
          return false;
        if (!this.service_name.equals(that.service_name))
          return false;
      }

      boolean this_present_span_name = true && this.isSetSpan_name();
      boolean that_present_span_name = true && that.isSetSpan_name();
      if (this_present_span_name || that_present_span_name) {
        if (!(this_present_span_name && that_present_span_name))
          return false;
        if (!this.span_name.equals(that.span_name))
          return false;
      }

      boolean this_present_end_ts = true;
      boolean that_present_end_ts = true;
      if (this_present_end_ts || that_present_end_ts) {
        if (!(this_present_end_ts && that_present_end_ts))
          return false;
        if (this.end_ts != that.end_ts)
          return false;
      }

      boolean this_present_limit = true;
      boolean that_present_limit = true;
      if (this_present_limit || that_present_limit) {
        if (!(this_present_limit && that_present_limit))
          return false;
        if (this.limit != that.limit)
          return false;
      }

      boolean this_present_order = true && this.isSetOrder();
      boolean that_present_order = true && that.isSetOrder();
      if (this_present_order || that_present_order) {
        if (!(this_present_order && that_present_order))
          return false;
        if (!this.order.equals(that.order))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTraceIdsBySpanName_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTraceIdsBySpanName_args typedOther = (getTraceIdsBySpanName_args)other;

      lastComparison = Boolean.valueOf(isSetService_name()).compareTo(typedOther.isSetService_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetService_name()) {
        lastComparison = TBaseHelper.compareTo(this.service_name, typedOther.service_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetSpan_name()).compareTo(typedOther.isSetSpan_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSpan_name()) {
        lastComparison = TBaseHelper.compareTo(this.span_name, typedOther.span_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetEnd_ts()).compareTo(typedOther.isSetEnd_ts());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetEnd_ts()) {
        lastComparison = TBaseHelper.compareTo(this.end_ts, typedOther.end_ts);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetLimit()).compareTo(typedOther.isSetLimit());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetLimit()) {
        lastComparison = TBaseHelper.compareTo(this.limit, typedOther.limit);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetOrder()).compareTo(typedOther.isSetOrder());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetOrder()) {
        lastComparison = TBaseHelper.compareTo(this.order, typedOther.order);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // SERVICE_NAME
            if (field.type == TType.STRING) {
              this.service_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // SPAN_NAME
            if (field.type == TType.STRING) {
              this.span_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // END_TS
            if (field.type == TType.I64) {
              this.end_ts = iprot.readI64();
              setEnd_tsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 5: // LIMIT
            if (field.type == TType.I32) {
              this.limit = iprot.readI32();
              setLimitIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 6: // ORDER
            if (field.type == TType.I32) {
              this.order = Order.findByValue(iprot.readI32());
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.service_name != null) {
        oprot.writeFieldBegin(SERVICE_NAME_FIELD_DESC);
        oprot.writeString(this.service_name);
        oprot.writeFieldEnd();
      }
      if (this.span_name != null) {
        oprot.writeFieldBegin(SPAN_NAME_FIELD_DESC);
        oprot.writeString(this.span_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(END_TS_FIELD_DESC);
      oprot.writeI64(this.end_ts);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(LIMIT_FIELD_DESC);
      oprot.writeI32(this.limit);
      oprot.writeFieldEnd();
      if (this.order != null) {
        oprot.writeFieldBegin(ORDER_FIELD_DESC);
        oprot.writeI32(this.order.getValue());
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTraceIdsBySpanName_args(");
      boolean first = true;

      sb.append("service_name:");
      if (this.service_name == null) {
        sb.append("null");
      } else {
        sb.append(this.service_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("span_name:");
      if (this.span_name == null) {
        sb.append("null");
      } else {
        sb.append(this.span_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("end_ts:");
      sb.append(this.end_ts);
      first = false;
      if (!first) sb.append(", ");
      sb.append("limit:");
      sb.append(this.limit);
      first = false;
      if (!first) sb.append(", ");
      sb.append("order:");
      if (this.order == null) {
        sb.append("null");
      } else {
        sb.append(this.order);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTraceIdsBySpanName_result implements TBase<getTraceIdsBySpanName_result, getTraceIdsBySpanName_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTraceIdsBySpanName_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField QE_FIELD_DESC = new TField("qe", TType.STRUCT, (short)1);

    public List<Long> success;
    public QueryException qe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      QE((short)1, "qe");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // QE
            return QE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.I64))));
      tmpMap.put(_Fields.QE, new FieldMetaData("qe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTraceIdsBySpanName_result.class, metaDataMap);
    }

    public getTraceIdsBySpanName_result() {
    }

    public getTraceIdsBySpanName_result(
      List<Long> success,
      QueryException qe)
    {
      this();
      this.success = success;
      this.qe = qe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTraceIdsBySpanName_result(getTraceIdsBySpanName_result other) {
      if (other.isSetSuccess()) {
        List<Long> __this__success = new ArrayList<Long>();
        for (Long other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetQe()) {
        this.qe = new QueryException(other.qe);
      }
    }

    public getTraceIdsBySpanName_result deepCopy() {
      return new getTraceIdsBySpanName_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.qe = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Long> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(long elem) {
      if (this.success == null) {
        this.success = new ArrayList<Long>();
      }
      this.success.add(elem);
    }

    public List<Long> getSuccess() {
      return this.success;
    }

    public getTraceIdsBySpanName_result setSuccess(List<Long> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public QueryException getQe() {
      return this.qe;
    }

    public getTraceIdsBySpanName_result setQe(QueryException qe) {
      this.qe = qe;
      return this;
    }

    public void unsetQe() {
      this.qe = null;
    }

    /** Returns true if field qe is set (has been asigned a value) and false otherwise */
    public boolean isSetQe() {
      return this.qe != null;
    }

    public void setQeIsSet(boolean value) {
      if (!value) {
        this.qe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Long>)value);
        }
        break;

      case QE:
        if (value == null) {
          unsetQe();
        } else {
          setQe((QueryException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case QE:
        return getQe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case QE:
        return isSetQe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTraceIdsBySpanName_result)
        return this.equals((getTraceIdsBySpanName_result)that);
      return false;
    }

    public boolean equals(getTraceIdsBySpanName_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_qe = true && this.isSetQe();
      boolean that_present_qe = true && that.isSetQe();
      if (this_present_qe || that_present_qe) {
        if (!(this_present_qe && that_present_qe))
          return false;
        if (!this.qe.equals(that.qe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTraceIdsBySpanName_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTraceIdsBySpanName_result typedOther = (getTraceIdsBySpanName_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetQe()).compareTo(typedOther.isSetQe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQe()) {
        lastComparison = TBaseHelper.compareTo(this.qe, typedOther.qe);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list38 = iprot.readListBegin();
                this.success = new ArrayList<Long>(_list38.size);
                for (int _i39 = 0; _i39 < _list38.size; ++_i39)
                {
                  long _elem40;
                  _elem40 = iprot.readI64();
                  this.success.add(_elem40);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // QE
            if (field.type == TType.STRUCT) {
              this.qe = new QueryException();
              this.qe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.I64, this.success.size()));
          for (long _iter41 : this.success)
          {
            oprot.writeI64(_iter41);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetQe()) {
        oprot.writeFieldBegin(QE_FIELD_DESC);
        this.qe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTraceIdsBySpanName_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("qe:");
      if (this.qe == null) {
        sb.append("null");
      } else {
        sb.append(this.qe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTraceIdsByServiceName_args implements TBase<getTraceIdsByServiceName_args, getTraceIdsByServiceName_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTraceIdsByServiceName_args");

    private static final TField SERVICE_NAME_FIELD_DESC = new TField("service_name", TType.STRING, (short)1);
    private static final TField END_TS_FIELD_DESC = new TField("end_ts", TType.I64, (short)3);
    private static final TField LIMIT_FIELD_DESC = new TField("limit", TType.I32, (short)4);
    private static final TField ORDER_FIELD_DESC = new TField("order", TType.I32, (short)5);

    public String service_name;
    public long end_ts;
    public int limit;
    /**
     * 
     * @see Order
     */
    public Order order;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SERVICE_NAME((short)1, "service_name"),
      END_TS((short)3, "end_ts"),
      LIMIT((short)4, "limit"),
      /**
       * 
       * @see Order
       */
      ORDER((short)5, "order");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SERVICE_NAME
            return SERVICE_NAME;
          case 3: // END_TS
            return END_TS;
          case 4: // LIMIT
            return LIMIT;
          case 5: // ORDER
            return ORDER;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __END_TS_ISSET_ID = 0;
    private static final int __LIMIT_ISSET_ID = 1;
    private BitSet __isset_bit_vector = new BitSet(2);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SERVICE_NAME, new FieldMetaData("service_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.END_TS, new FieldMetaData("end_ts", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      tmpMap.put(_Fields.LIMIT, new FieldMetaData("limit", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      tmpMap.put(_Fields.ORDER, new FieldMetaData("order", TFieldRequirementType.DEFAULT, 
          new EnumMetaData(TType.ENUM, Order.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTraceIdsByServiceName_args.class, metaDataMap);
    }

    public getTraceIdsByServiceName_args() {
    }

    public getTraceIdsByServiceName_args(
      String service_name,
      long end_ts,
      int limit,
      Order order)
    {
      this();
      this.service_name = service_name;
      this.end_ts = end_ts;
      setEnd_tsIsSet(true);
      this.limit = limit;
      setLimitIsSet(true);
      this.order = order;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTraceIdsByServiceName_args(getTraceIdsByServiceName_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetService_name()) {
        this.service_name = other.service_name;
      }
      this.end_ts = other.end_ts;
      this.limit = other.limit;
      if (other.isSetOrder()) {
        this.order = other.order;
      }
    }

    public getTraceIdsByServiceName_args deepCopy() {
      return new getTraceIdsByServiceName_args(this);
    }

    @Override
    public void clear() {
      this.service_name = null;
      setEnd_tsIsSet(false);
      this.end_ts = 0;
      setLimitIsSet(false);
      this.limit = 0;
      this.order = null;
    }

    public String getService_name() {
      return this.service_name;
    }

    public getTraceIdsByServiceName_args setService_name(String service_name) {
      this.service_name = service_name;
      return this;
    }

    public void unsetService_name() {
      this.service_name = null;
    }

    /** Returns true if field service_name is set (has been asigned a value) and false otherwise */
    public boolean isSetService_name() {
      return this.service_name != null;
    }

    public void setService_nameIsSet(boolean value) {
      if (!value) {
        this.service_name = null;
      }
    }

    public long getEnd_ts() {
      return this.end_ts;
    }

    public getTraceIdsByServiceName_args setEnd_ts(long end_ts) {
      this.end_ts = end_ts;
      setEnd_tsIsSet(true);
      return this;
    }

    public void unsetEnd_ts() {
      __isset_bit_vector.clear(__END_TS_ISSET_ID);
    }

    /** Returns true if field end_ts is set (has been asigned a value) and false otherwise */
    public boolean isSetEnd_ts() {
      return __isset_bit_vector.get(__END_TS_ISSET_ID);
    }

    public void setEnd_tsIsSet(boolean value) {
      __isset_bit_vector.set(__END_TS_ISSET_ID, value);
    }

    public int getLimit() {
      return this.limit;
    }

    public getTraceIdsByServiceName_args setLimit(int limit) {
      this.limit = limit;
      setLimitIsSet(true);
      return this;
    }

    public void unsetLimit() {
      __isset_bit_vector.clear(__LIMIT_ISSET_ID);
    }

    /** Returns true if field limit is set (has been asigned a value) and false otherwise */
    public boolean isSetLimit() {
      return __isset_bit_vector.get(__LIMIT_ISSET_ID);
    }

    public void setLimitIsSet(boolean value) {
      __isset_bit_vector.set(__LIMIT_ISSET_ID, value);
    }

    /**
     * 
     * @see Order
     */
    public Order getOrder() {
      return this.order;
    }

    /**
     * 
     * @see Order
     */
    public getTraceIdsByServiceName_args setOrder(Order order) {
      this.order = order;
      return this;
    }

    public void unsetOrder() {
      this.order = null;
    }

    /** Returns true if field order is set (has been asigned a value) and false otherwise */
    public boolean isSetOrder() {
      return this.order != null;
    }

    public void setOrderIsSet(boolean value) {
      if (!value) {
        this.order = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SERVICE_NAME:
        if (value == null) {
          unsetService_name();
        } else {
          setService_name((String)value);
        }
        break;

      case END_TS:
        if (value == null) {
          unsetEnd_ts();
        } else {
          setEnd_ts((Long)value);
        }
        break;

      case LIMIT:
        if (value == null) {
          unsetLimit();
        } else {
          setLimit((Integer)value);
        }
        break;

      case ORDER:
        if (value == null) {
          unsetOrder();
        } else {
          setOrder((Order)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SERVICE_NAME:
        return getService_name();

      case END_TS:
        return new Long(getEnd_ts());

      case LIMIT:
        return new Integer(getLimit());

      case ORDER:
        return getOrder();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SERVICE_NAME:
        return isSetService_name();
      case END_TS:
        return isSetEnd_ts();
      case LIMIT:
        return isSetLimit();
      case ORDER:
        return isSetOrder();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTraceIdsByServiceName_args)
        return this.equals((getTraceIdsByServiceName_args)that);
      return false;
    }

    public boolean equals(getTraceIdsByServiceName_args that) {
      if (that == null)
        return false;

      boolean this_present_service_name = true && this.isSetService_name();
      boolean that_present_service_name = true && that.isSetService_name();
      if (this_present_service_name || that_present_service_name) {
        if (!(this_present_service_name && that_present_service_name))
          return false;
        if (!this.service_name.equals(that.service_name))
          return false;
      }

      boolean this_present_end_ts = true;
      boolean that_present_end_ts = true;
      if (this_present_end_ts || that_present_end_ts) {
        if (!(this_present_end_ts && that_present_end_ts))
          return false;
        if (this.end_ts != that.end_ts)
          return false;
      }

      boolean this_present_limit = true;
      boolean that_present_limit = true;
      if (this_present_limit || that_present_limit) {
        if (!(this_present_limit && that_present_limit))
          return false;
        if (this.limit != that.limit)
          return false;
      }

      boolean this_present_order = true && this.isSetOrder();
      boolean that_present_order = true && that.isSetOrder();
      if (this_present_order || that_present_order) {
        if (!(this_present_order && that_present_order))
          return false;
        if (!this.order.equals(that.order))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTraceIdsByServiceName_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTraceIdsByServiceName_args typedOther = (getTraceIdsByServiceName_args)other;

      lastComparison = Boolean.valueOf(isSetService_name()).compareTo(typedOther.isSetService_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetService_name()) {
        lastComparison = TBaseHelper.compareTo(this.service_name, typedOther.service_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetEnd_ts()).compareTo(typedOther.isSetEnd_ts());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetEnd_ts()) {
        lastComparison = TBaseHelper.compareTo(this.end_ts, typedOther.end_ts);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetLimit()).compareTo(typedOther.isSetLimit());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetLimit()) {
        lastComparison = TBaseHelper.compareTo(this.limit, typedOther.limit);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetOrder()).compareTo(typedOther.isSetOrder());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetOrder()) {
        lastComparison = TBaseHelper.compareTo(this.order, typedOther.order);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // SERVICE_NAME
            if (field.type == TType.STRING) {
              this.service_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // END_TS
            if (field.type == TType.I64) {
              this.end_ts = iprot.readI64();
              setEnd_tsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 4: // LIMIT
            if (field.type == TType.I32) {
              this.limit = iprot.readI32();
              setLimitIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 5: // ORDER
            if (field.type == TType.I32) {
              this.order = Order.findByValue(iprot.readI32());
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.service_name != null) {
        oprot.writeFieldBegin(SERVICE_NAME_FIELD_DESC);
        oprot.writeString(this.service_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(END_TS_FIELD_DESC);
      oprot.writeI64(this.end_ts);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(LIMIT_FIELD_DESC);
      oprot.writeI32(this.limit);
      oprot.writeFieldEnd();
      if (this.order != null) {
        oprot.writeFieldBegin(ORDER_FIELD_DESC);
        oprot.writeI32(this.order.getValue());
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTraceIdsByServiceName_args(");
      boolean first = true;

      sb.append("service_name:");
      if (this.service_name == null) {
        sb.append("null");
      } else {
        sb.append(this.service_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("end_ts:");
      sb.append(this.end_ts);
      first = false;
      if (!first) sb.append(", ");
      sb.append("limit:");
      sb.append(this.limit);
      first = false;
      if (!first) sb.append(", ");
      sb.append("order:");
      if (this.order == null) {
        sb.append("null");
      } else {
        sb.append(this.order);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTraceIdsByServiceName_result implements TBase<getTraceIdsByServiceName_result, getTraceIdsByServiceName_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTraceIdsByServiceName_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField QE_FIELD_DESC = new TField("qe", TType.STRUCT, (short)1);

    public List<Long> success;
    public QueryException qe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      QE((short)1, "qe");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // QE
            return QE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.I64))));
      tmpMap.put(_Fields.QE, new FieldMetaData("qe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTraceIdsByServiceName_result.class, metaDataMap);
    }

    public getTraceIdsByServiceName_result() {
    }

    public getTraceIdsByServiceName_result(
      List<Long> success,
      QueryException qe)
    {
      this();
      this.success = success;
      this.qe = qe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTraceIdsByServiceName_result(getTraceIdsByServiceName_result other) {
      if (other.isSetSuccess()) {
        List<Long> __this__success = new ArrayList<Long>();
        for (Long other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetQe()) {
        this.qe = new QueryException(other.qe);
      }
    }

    public getTraceIdsByServiceName_result deepCopy() {
      return new getTraceIdsByServiceName_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.qe = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Long> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(long elem) {
      if (this.success == null) {
        this.success = new ArrayList<Long>();
      }
      this.success.add(elem);
    }

    public List<Long> getSuccess() {
      return this.success;
    }

    public getTraceIdsByServiceName_result setSuccess(List<Long> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public QueryException getQe() {
      return this.qe;
    }

    public getTraceIdsByServiceName_result setQe(QueryException qe) {
      this.qe = qe;
      return this;
    }

    public void unsetQe() {
      this.qe = null;
    }

    /** Returns true if field qe is set (has been asigned a value) and false otherwise */
    public boolean isSetQe() {
      return this.qe != null;
    }

    public void setQeIsSet(boolean value) {
      if (!value) {
        this.qe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Long>)value);
        }
        break;

      case QE:
        if (value == null) {
          unsetQe();
        } else {
          setQe((QueryException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case QE:
        return getQe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case QE:
        return isSetQe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTraceIdsByServiceName_result)
        return this.equals((getTraceIdsByServiceName_result)that);
      return false;
    }

    public boolean equals(getTraceIdsByServiceName_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_qe = true && this.isSetQe();
      boolean that_present_qe = true && that.isSetQe();
      if (this_present_qe || that_present_qe) {
        if (!(this_present_qe && that_present_qe))
          return false;
        if (!this.qe.equals(that.qe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTraceIdsByServiceName_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTraceIdsByServiceName_result typedOther = (getTraceIdsByServiceName_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetQe()).compareTo(typedOther.isSetQe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQe()) {
        lastComparison = TBaseHelper.compareTo(this.qe, typedOther.qe);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list42 = iprot.readListBegin();
                this.success = new ArrayList<Long>(_list42.size);
                for (int _i43 = 0; _i43 < _list42.size; ++_i43)
                {
                  long _elem44;
                  _elem44 = iprot.readI64();
                  this.success.add(_elem44);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // QE
            if (field.type == TType.STRUCT) {
              this.qe = new QueryException();
              this.qe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.I64, this.success.size()));
          for (long _iter45 : this.success)
          {
            oprot.writeI64(_iter45);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetQe()) {
        oprot.writeFieldBegin(QE_FIELD_DESC);
        this.qe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTraceIdsByServiceName_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("qe:");
      if (this.qe == null) {
        sb.append("null");
      } else {
        sb.append(this.qe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTraceIdsByAnnotation_args implements TBase<getTraceIdsByAnnotation_args, getTraceIdsByAnnotation_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTraceIdsByAnnotation_args");

    private static final TField SERVICE_NAME_FIELD_DESC = new TField("service_name", TType.STRING, (short)1);
    private static final TField ANNOTATION_FIELD_DESC = new TField("annotation", TType.STRING, (short)2);
    private static final TField VALUE_FIELD_DESC = new TField("value", TType.STRING, (short)3);
    private static final TField END_TS_FIELD_DESC = new TField("end_ts", TType.I64, (short)5);
    private static final TField LIMIT_FIELD_DESC = new TField("limit", TType.I32, (short)6);
    private static final TField ORDER_FIELD_DESC = new TField("order", TType.I32, (short)7);

    public String service_name;
    public String annotation;
    public ByteBuffer value;
    public long end_ts;
    public int limit;
    /**
     * 
     * @see Order
     */
    public Order order;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SERVICE_NAME((short)1, "service_name"),
      ANNOTATION((short)2, "annotation"),
      VALUE((short)3, "value"),
      END_TS((short)5, "end_ts"),
      LIMIT((short)6, "limit"),
      /**
       * 
       * @see Order
       */
      ORDER((short)7, "order");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SERVICE_NAME
            return SERVICE_NAME;
          case 2: // ANNOTATION
            return ANNOTATION;
          case 3: // VALUE
            return VALUE;
          case 5: // END_TS
            return END_TS;
          case 6: // LIMIT
            return LIMIT;
          case 7: // ORDER
            return ORDER;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __END_TS_ISSET_ID = 0;
    private static final int __LIMIT_ISSET_ID = 1;
    private BitSet __isset_bit_vector = new BitSet(2);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SERVICE_NAME, new FieldMetaData("service_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.ANNOTATION, new FieldMetaData("annotation", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.VALUE, new FieldMetaData("value", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      tmpMap.put(_Fields.END_TS, new FieldMetaData("end_ts", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      tmpMap.put(_Fields.LIMIT, new FieldMetaData("limit", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      tmpMap.put(_Fields.ORDER, new FieldMetaData("order", TFieldRequirementType.DEFAULT, 
          new EnumMetaData(TType.ENUM, Order.class)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTraceIdsByAnnotation_args.class, metaDataMap);
    }

    public getTraceIdsByAnnotation_args() {
    }

    public getTraceIdsByAnnotation_args(
      String service_name,
      String annotation,
      ByteBuffer value,
      long end_ts,
      int limit,
      Order order)
    {
      this();
      this.service_name = service_name;
      this.annotation = annotation;
      this.value = value;
      this.end_ts = end_ts;
      setEnd_tsIsSet(true);
      this.limit = limit;
      setLimitIsSet(true);
      this.order = order;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTraceIdsByAnnotation_args(getTraceIdsByAnnotation_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      if (other.isSetService_name()) {
        this.service_name = other.service_name;
      }
      if (other.isSetAnnotation()) {
        this.annotation = other.annotation;
      }
      if (other.isSetValue()) {
        this.value = TBaseHelper.copyBinary(other.value);
;
      }
      this.end_ts = other.end_ts;
      this.limit = other.limit;
      if (other.isSetOrder()) {
        this.order = other.order;
      }
    }

    public getTraceIdsByAnnotation_args deepCopy() {
      return new getTraceIdsByAnnotation_args(this);
    }

    @Override
    public void clear() {
      this.service_name = null;
      this.annotation = null;
      this.value = null;
      setEnd_tsIsSet(false);
      this.end_ts = 0;
      setLimitIsSet(false);
      this.limit = 0;
      this.order = null;
    }

    public String getService_name() {
      return this.service_name;
    }

    public getTraceIdsByAnnotation_args setService_name(String service_name) {
      this.service_name = service_name;
      return this;
    }

    public void unsetService_name() {
      this.service_name = null;
    }

    /** Returns true if field service_name is set (has been asigned a value) and false otherwise */
    public boolean isSetService_name() {
      return this.service_name != null;
    }

    public void setService_nameIsSet(boolean value) {
      if (!value) {
        this.service_name = null;
      }
    }

    public String getAnnotation() {
      return this.annotation;
    }

    public getTraceIdsByAnnotation_args setAnnotation(String annotation) {
      this.annotation = annotation;
      return this;
    }

    public void unsetAnnotation() {
      this.annotation = null;
    }

    /** Returns true if field annotation is set (has been asigned a value) and false otherwise */
    public boolean isSetAnnotation() {
      return this.annotation != null;
    }

    public void setAnnotationIsSet(boolean value) {
      if (!value) {
        this.annotation = null;
      }
    }

    public byte[] getValue() {
      setValue(TBaseHelper.rightSize(value));
      return value.array();
    }

    public ByteBuffer BufferForValue() {
      return value;
    }

    public getTraceIdsByAnnotation_args setValue(byte[] value) {
      setValue(ByteBuffer.wrap(value));
      return this;
    }

    public getTraceIdsByAnnotation_args setValue(ByteBuffer value) {
      this.value = value;
      return this;
    }

    public void unsetValue() {
      this.value = null;
    }

    /** Returns true if field value is set (has been asigned a value) and false otherwise */
    public boolean isSetValue() {
      return this.value != null;
    }

    public void setValueIsSet(boolean value) {
      if (!value) {
        this.value = null;
      }
    }

    public long getEnd_ts() {
      return this.end_ts;
    }

    public getTraceIdsByAnnotation_args setEnd_ts(long end_ts) {
      this.end_ts = end_ts;
      setEnd_tsIsSet(true);
      return this;
    }

    public void unsetEnd_ts() {
      __isset_bit_vector.clear(__END_TS_ISSET_ID);
    }

    /** Returns true if field end_ts is set (has been asigned a value) and false otherwise */
    public boolean isSetEnd_ts() {
      return __isset_bit_vector.get(__END_TS_ISSET_ID);
    }

    public void setEnd_tsIsSet(boolean value) {
      __isset_bit_vector.set(__END_TS_ISSET_ID, value);
    }

    public int getLimit() {
      return this.limit;
    }

    public getTraceIdsByAnnotation_args setLimit(int limit) {
      this.limit = limit;
      setLimitIsSet(true);
      return this;
    }

    public void unsetLimit() {
      __isset_bit_vector.clear(__LIMIT_ISSET_ID);
    }

    /** Returns true if field limit is set (has been asigned a value) and false otherwise */
    public boolean isSetLimit() {
      return __isset_bit_vector.get(__LIMIT_ISSET_ID);
    }

    public void setLimitIsSet(boolean value) {
      __isset_bit_vector.set(__LIMIT_ISSET_ID, value);
    }

    /**
     * 
     * @see Order
     */
    public Order getOrder() {
      return this.order;
    }

    /**
     * 
     * @see Order
     */
    public getTraceIdsByAnnotation_args setOrder(Order order) {
      this.order = order;
      return this;
    }

    public void unsetOrder() {
      this.order = null;
    }

    /** Returns true if field order is set (has been asigned a value) and false otherwise */
    public boolean isSetOrder() {
      return this.order != null;
    }

    public void setOrderIsSet(boolean value) {
      if (!value) {
        this.order = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SERVICE_NAME:
        if (value == null) {
          unsetService_name();
        } else {
          setService_name((String)value);
        }
        break;

      case ANNOTATION:
        if (value == null) {
          unsetAnnotation();
        } else {
          setAnnotation((String)value);
        }
        break;

      case VALUE:
        if (value == null) {
          unsetValue();
        } else {
          setValue((ByteBuffer)value);
        }
        break;

      case END_TS:
        if (value == null) {
          unsetEnd_ts();
        } else {
          setEnd_ts((Long)value);
        }
        break;

      case LIMIT:
        if (value == null) {
          unsetLimit();
        } else {
          setLimit((Integer)value);
        }
        break;

      case ORDER:
        if (value == null) {
          unsetOrder();
        } else {
          setOrder((Order)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SERVICE_NAME:
        return getService_name();

      case ANNOTATION:
        return getAnnotation();

      case VALUE:
        return getValue();

      case END_TS:
        return new Long(getEnd_ts());

      case LIMIT:
        return new Integer(getLimit());

      case ORDER:
        return getOrder();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SERVICE_NAME:
        return isSetService_name();
      case ANNOTATION:
        return isSetAnnotation();
      case VALUE:
        return isSetValue();
      case END_TS:
        return isSetEnd_ts();
      case LIMIT:
        return isSetLimit();
      case ORDER:
        return isSetOrder();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTraceIdsByAnnotation_args)
        return this.equals((getTraceIdsByAnnotation_args)that);
      return false;
    }

    public boolean equals(getTraceIdsByAnnotation_args that) {
      if (that == null)
        return false;

      boolean this_present_service_name = true && this.isSetService_name();
      boolean that_present_service_name = true && that.isSetService_name();
      if (this_present_service_name || that_present_service_name) {
        if (!(this_present_service_name && that_present_service_name))
          return false;
        if (!this.service_name.equals(that.service_name))
          return false;
      }

      boolean this_present_annotation = true && this.isSetAnnotation();
      boolean that_present_annotation = true && that.isSetAnnotation();
      if (this_present_annotation || that_present_annotation) {
        if (!(this_present_annotation && that_present_annotation))
          return false;
        if (!this.annotation.equals(that.annotation))
          return false;
      }

      boolean this_present_value = true && this.isSetValue();
      boolean that_present_value = true && that.isSetValue();
      if (this_present_value || that_present_value) {
        if (!(this_present_value && that_present_value))
          return false;
        if (!this.value.equals(that.value))
          return false;
      }

      boolean this_present_end_ts = true;
      boolean that_present_end_ts = true;
      if (this_present_end_ts || that_present_end_ts) {
        if (!(this_present_end_ts && that_present_end_ts))
          return false;
        if (this.end_ts != that.end_ts)
          return false;
      }

      boolean this_present_limit = true;
      boolean that_present_limit = true;
      if (this_present_limit || that_present_limit) {
        if (!(this_present_limit && that_present_limit))
          return false;
        if (this.limit != that.limit)
          return false;
      }

      boolean this_present_order = true && this.isSetOrder();
      boolean that_present_order = true && that.isSetOrder();
      if (this_present_order || that_present_order) {
        if (!(this_present_order && that_present_order))
          return false;
        if (!this.order.equals(that.order))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTraceIdsByAnnotation_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTraceIdsByAnnotation_args typedOther = (getTraceIdsByAnnotation_args)other;

      lastComparison = Boolean.valueOf(isSetService_name()).compareTo(typedOther.isSetService_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetService_name()) {
        lastComparison = TBaseHelper.compareTo(this.service_name, typedOther.service_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetAnnotation()).compareTo(typedOther.isSetAnnotation());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetAnnotation()) {
        lastComparison = TBaseHelper.compareTo(this.annotation, typedOther.annotation);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetValue()).compareTo(typedOther.isSetValue());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetValue()) {
        lastComparison = TBaseHelper.compareTo(this.value, typedOther.value);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetEnd_ts()).compareTo(typedOther.isSetEnd_ts());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetEnd_ts()) {
        lastComparison = TBaseHelper.compareTo(this.end_ts, typedOther.end_ts);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetLimit()).compareTo(typedOther.isSetLimit());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetLimit()) {
        lastComparison = TBaseHelper.compareTo(this.limit, typedOther.limit);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetOrder()).compareTo(typedOther.isSetOrder());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetOrder()) {
        lastComparison = TBaseHelper.compareTo(this.order, typedOther.order);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // SERVICE_NAME
            if (field.type == TType.STRING) {
              this.service_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ANNOTATION
            if (field.type == TType.STRING) {
              this.annotation = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 3: // VALUE
            if (field.type == TType.STRING) {
              this.value = iprot.readBinary();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 5: // END_TS
            if (field.type == TType.I64) {
              this.end_ts = iprot.readI64();
              setEnd_tsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 6: // LIMIT
            if (field.type == TType.I32) {
              this.limit = iprot.readI32();
              setLimitIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 7: // ORDER
            if (field.type == TType.I32) {
              this.order = Order.findByValue(iprot.readI32());
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.service_name != null) {
        oprot.writeFieldBegin(SERVICE_NAME_FIELD_DESC);
        oprot.writeString(this.service_name);
        oprot.writeFieldEnd();
      }
      if (this.annotation != null) {
        oprot.writeFieldBegin(ANNOTATION_FIELD_DESC);
        oprot.writeString(this.annotation);
        oprot.writeFieldEnd();
      }
      if (this.value != null) {
        oprot.writeFieldBegin(VALUE_FIELD_DESC);
        oprot.writeBinary(this.value);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldBegin(END_TS_FIELD_DESC);
      oprot.writeI64(this.end_ts);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(LIMIT_FIELD_DESC);
      oprot.writeI32(this.limit);
      oprot.writeFieldEnd();
      if (this.order != null) {
        oprot.writeFieldBegin(ORDER_FIELD_DESC);
        oprot.writeI32(this.order.getValue());
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTraceIdsByAnnotation_args(");
      boolean first = true;

      sb.append("service_name:");
      if (this.service_name == null) {
        sb.append("null");
      } else {
        sb.append(this.service_name);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("annotation:");
      if (this.annotation == null) {
        sb.append("null");
      } else {
        sb.append(this.annotation);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("value:");
      if (this.value == null) {
        sb.append("null");
      } else {
        TBaseHelper.toString(this.value, sb);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("end_ts:");
      sb.append(this.end_ts);
      first = false;
      if (!first) sb.append(", ");
      sb.append("limit:");
      sb.append(this.limit);
      first = false;
      if (!first) sb.append(", ");
      sb.append("order:");
      if (this.order == null) {
        sb.append("null");
      } else {
        sb.append(this.order);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTraceIdsByAnnotation_result implements TBase<getTraceIdsByAnnotation_result, getTraceIdsByAnnotation_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTraceIdsByAnnotation_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField QE_FIELD_DESC = new TField("qe", TType.STRUCT, (short)1);

    public List<Long> success;
    public QueryException qe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      QE((short)1, "qe");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // QE
            return QE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.I64))));
      tmpMap.put(_Fields.QE, new FieldMetaData("qe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTraceIdsByAnnotation_result.class, metaDataMap);
    }

    public getTraceIdsByAnnotation_result() {
    }

    public getTraceIdsByAnnotation_result(
      List<Long> success,
      QueryException qe)
    {
      this();
      this.success = success;
      this.qe = qe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTraceIdsByAnnotation_result(getTraceIdsByAnnotation_result other) {
      if (other.isSetSuccess()) {
        List<Long> __this__success = new ArrayList<Long>();
        for (Long other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetQe()) {
        this.qe = new QueryException(other.qe);
      }
    }

    public getTraceIdsByAnnotation_result deepCopy() {
      return new getTraceIdsByAnnotation_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.qe = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Long> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(long elem) {
      if (this.success == null) {
        this.success = new ArrayList<Long>();
      }
      this.success.add(elem);
    }

    public List<Long> getSuccess() {
      return this.success;
    }

    public getTraceIdsByAnnotation_result setSuccess(List<Long> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public QueryException getQe() {
      return this.qe;
    }

    public getTraceIdsByAnnotation_result setQe(QueryException qe) {
      this.qe = qe;
      return this;
    }

    public void unsetQe() {
      this.qe = null;
    }

    /** Returns true if field qe is set (has been asigned a value) and false otherwise */
    public boolean isSetQe() {
      return this.qe != null;
    }

    public void setQeIsSet(boolean value) {
      if (!value) {
        this.qe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Long>)value);
        }
        break;

      case QE:
        if (value == null) {
          unsetQe();
        } else {
          setQe((QueryException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case QE:
        return getQe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case QE:
        return isSetQe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTraceIdsByAnnotation_result)
        return this.equals((getTraceIdsByAnnotation_result)that);
      return false;
    }

    public boolean equals(getTraceIdsByAnnotation_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_qe = true && this.isSetQe();
      boolean that_present_qe = true && that.isSetQe();
      if (this_present_qe || that_present_qe) {
        if (!(this_present_qe && that_present_qe))
          return false;
        if (!this.qe.equals(that.qe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTraceIdsByAnnotation_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTraceIdsByAnnotation_result typedOther = (getTraceIdsByAnnotation_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetQe()).compareTo(typedOther.isSetQe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQe()) {
        lastComparison = TBaseHelper.compareTo(this.qe, typedOther.qe);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list46 = iprot.readListBegin();
                this.success = new ArrayList<Long>(_list46.size);
                for (int _i47 = 0; _i47 < _list46.size; ++_i47)
                {
                  long _elem48;
                  _elem48 = iprot.readI64();
                  this.success.add(_elem48);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // QE
            if (field.type == TType.STRUCT) {
              this.qe = new QueryException();
              this.qe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.I64, this.success.size()));
          for (long _iter49 : this.success)
          {
            oprot.writeI64(_iter49);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetQe()) {
        oprot.writeFieldBegin(QE_FIELD_DESC);
        this.qe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTraceIdsByAnnotation_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("qe:");
      if (this.qe == null) {
        sb.append("null");
      } else {
        sb.append(this.qe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class tracesExist_args implements TBase<tracesExist_args, tracesExist_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("tracesExist_args");

    private static final TField TRACE_IDS_FIELD_DESC = new TField("trace_ids", TType.LIST, (short)1);

    public List<Long> trace_ids;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TRACE_IDS((short)1, "trace_ids");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TRACE_IDS
            return TRACE_IDS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TRACE_IDS, new FieldMetaData("trace_ids", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.I64))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(tracesExist_args.class, metaDataMap);
    }

    public tracesExist_args() {
    }

    public tracesExist_args(
      List<Long> trace_ids)
    {
      this();
      this.trace_ids = trace_ids;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public tracesExist_args(tracesExist_args other) {
      if (other.isSetTrace_ids()) {
        List<Long> __this__trace_ids = new ArrayList<Long>();
        for (Long other_element : other.trace_ids) {
          __this__trace_ids.add(other_element);
        }
        this.trace_ids = __this__trace_ids;
      }
    }

    public tracesExist_args deepCopy() {
      return new tracesExist_args(this);
    }

    @Override
    public void clear() {
      this.trace_ids = null;
    }

    public int getTrace_idsSize() {
      return (this.trace_ids == null) ? 0 : this.trace_ids.size();
    }

    public java.util.Iterator<Long> getTrace_idsIterator() {
      return (this.trace_ids == null) ? null : this.trace_ids.iterator();
    }

    public void addToTrace_ids(long elem) {
      if (this.trace_ids == null) {
        this.trace_ids = new ArrayList<Long>();
      }
      this.trace_ids.add(elem);
    }

    public List<Long> getTrace_ids() {
      return this.trace_ids;
    }

    public tracesExist_args setTrace_ids(List<Long> trace_ids) {
      this.trace_ids = trace_ids;
      return this;
    }

    public void unsetTrace_ids() {
      this.trace_ids = null;
    }

    /** Returns true if field trace_ids is set (has been asigned a value) and false otherwise */
    public boolean isSetTrace_ids() {
      return this.trace_ids != null;
    }

    public void setTrace_idsIsSet(boolean value) {
      if (!value) {
        this.trace_ids = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TRACE_IDS:
        if (value == null) {
          unsetTrace_ids();
        } else {
          setTrace_ids((List<Long>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TRACE_IDS:
        return getTrace_ids();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TRACE_IDS:
        return isSetTrace_ids();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof tracesExist_args)
        return this.equals((tracesExist_args)that);
      return false;
    }

    public boolean equals(tracesExist_args that) {
      if (that == null)
        return false;

      boolean this_present_trace_ids = true && this.isSetTrace_ids();
      boolean that_present_trace_ids = true && that.isSetTrace_ids();
      if (this_present_trace_ids || that_present_trace_ids) {
        if (!(this_present_trace_ids && that_present_trace_ids))
          return false;
        if (!this.trace_ids.equals(that.trace_ids))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(tracesExist_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      tracesExist_args typedOther = (tracesExist_args)other;

      lastComparison = Boolean.valueOf(isSetTrace_ids()).compareTo(typedOther.isSetTrace_ids());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTrace_ids()) {
        lastComparison = TBaseHelper.compareTo(this.trace_ids, typedOther.trace_ids);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // TRACE_IDS
            if (field.type == TType.LIST) {
              {
                TList _list50 = iprot.readListBegin();
                this.trace_ids = new ArrayList<Long>(_list50.size);
                for (int _i51 = 0; _i51 < _list50.size; ++_i51)
                {
                  long _elem52;
                  _elem52 = iprot.readI64();
                  this.trace_ids.add(_elem52);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.trace_ids != null) {
        oprot.writeFieldBegin(TRACE_IDS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.I64, this.trace_ids.size()));
          for (long _iter53 : this.trace_ids)
          {
            oprot.writeI64(_iter53);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("tracesExist_args(");
      boolean first = true;

      sb.append("trace_ids:");
      if (this.trace_ids == null) {
        sb.append("null");
      } else {
        sb.append(this.trace_ids);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class tracesExist_result implements TBase<tracesExist_result, tracesExist_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("tracesExist_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.SET, (short)0);
    private static final TField QE_FIELD_DESC = new TField("qe", TType.STRUCT, (short)1);

    public Set<Long> success;
    public QueryException qe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      QE((short)1, "qe");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // QE
            return QE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new SetMetaData(TType.SET, 
              new FieldValueMetaData(TType.I64))));
      tmpMap.put(_Fields.QE, new FieldMetaData("qe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(tracesExist_result.class, metaDataMap);
    }

    public tracesExist_result() {
    }

    public tracesExist_result(
      Set<Long> success,
      QueryException qe)
    {
      this();
      this.success = success;
      this.qe = qe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public tracesExist_result(tracesExist_result other) {
      if (other.isSetSuccess()) {
        Set<Long> __this__success = new HashSet<Long>();
        for (Long other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetQe()) {
        this.qe = new QueryException(other.qe);
      }
    }

    public tracesExist_result deepCopy() {
      return new tracesExist_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.qe = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Long> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(long elem) {
      if (this.success == null) {
        this.success = new HashSet<Long>();
      }
      this.success.add(elem);
    }

    public Set<Long> getSuccess() {
      return this.success;
    }

    public tracesExist_result setSuccess(Set<Long> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public QueryException getQe() {
      return this.qe;
    }

    public tracesExist_result setQe(QueryException qe) {
      this.qe = qe;
      return this;
    }

    public void unsetQe() {
      this.qe = null;
    }

    /** Returns true if field qe is set (has been asigned a value) and false otherwise */
    public boolean isSetQe() {
      return this.qe != null;
    }

    public void setQeIsSet(boolean value) {
      if (!value) {
        this.qe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Set<Long>)value);
        }
        break;

      case QE:
        if (value == null) {
          unsetQe();
        } else {
          setQe((QueryException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case QE:
        return getQe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case QE:
        return isSetQe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof tracesExist_result)
        return this.equals((tracesExist_result)that);
      return false;
    }

    public boolean equals(tracesExist_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_qe = true && this.isSetQe();
      boolean that_present_qe = true && that.isSetQe();
      if (this_present_qe || that_present_qe) {
        if (!(this_present_qe && that_present_qe))
          return false;
        if (!this.qe.equals(that.qe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(tracesExist_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      tracesExist_result typedOther = (tracesExist_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetQe()).compareTo(typedOther.isSetQe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQe()) {
        lastComparison = TBaseHelper.compareTo(this.qe, typedOther.qe);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.SET) {
              {
                TSet _set54 = iprot.readSetBegin();
                this.success = new HashSet<Long>(2*_set54.size);
                for (int _i55 = 0; _i55 < _set54.size; ++_i55)
                {
                  long _elem56;
                  _elem56 = iprot.readI64();
                  this.success.add(_elem56);
                }
                iprot.readSetEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // QE
            if (field.type == TType.STRUCT) {
              this.qe = new QueryException();
              this.qe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeSetBegin(new TSet(TType.I64, this.success.size()));
          for (long _iter57 : this.success)
          {
            oprot.writeI64(_iter57);
          }
          oprot.writeSetEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetQe()) {
        oprot.writeFieldBegin(QE_FIELD_DESC);
        this.qe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("tracesExist_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("qe:");
      if (this.qe == null) {
        sb.append("null");
      } else {
        sb.append(this.qe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTracesByIds_args implements TBase<getTracesByIds_args, getTracesByIds_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTracesByIds_args");

    private static final TField TRACE_IDS_FIELD_DESC = new TField("trace_ids", TType.LIST, (short)1);
    private static final TField ADJUST_FIELD_DESC = new TField("adjust", TType.LIST, (short)2);

    public List<Long> trace_ids;
    public List<Adjust> adjust;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TRACE_IDS((short)1, "trace_ids"),
      ADJUST((short)2, "adjust");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TRACE_IDS
            return TRACE_IDS;
          case 2: // ADJUST
            return ADJUST;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TRACE_IDS, new FieldMetaData("trace_ids", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.I64))));
      tmpMap.put(_Fields.ADJUST, new FieldMetaData("adjust", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new EnumMetaData(TType.ENUM, Adjust.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTracesByIds_args.class, metaDataMap);
    }

    public getTracesByIds_args() {
    }

    public getTracesByIds_args(
      List<Long> trace_ids,
      List<Adjust> adjust)
    {
      this();
      this.trace_ids = trace_ids;
      this.adjust = adjust;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTracesByIds_args(getTracesByIds_args other) {
      if (other.isSetTrace_ids()) {
        List<Long> __this__trace_ids = new ArrayList<Long>();
        for (Long other_element : other.trace_ids) {
          __this__trace_ids.add(other_element);
        }
        this.trace_ids = __this__trace_ids;
      }
      if (other.isSetAdjust()) {
        List<Adjust> __this__adjust = new ArrayList<Adjust>();
        for (Adjust other_element : other.adjust) {
          __this__adjust.add(other_element);
        }
        this.adjust = __this__adjust;
      }
    }

    public getTracesByIds_args deepCopy() {
      return new getTracesByIds_args(this);
    }

    @Override
    public void clear() {
      this.trace_ids = null;
      this.adjust = null;
    }

    public int getTrace_idsSize() {
      return (this.trace_ids == null) ? 0 : this.trace_ids.size();
    }

    public java.util.Iterator<Long> getTrace_idsIterator() {
      return (this.trace_ids == null) ? null : this.trace_ids.iterator();
    }

    public void addToTrace_ids(long elem) {
      if (this.trace_ids == null) {
        this.trace_ids = new ArrayList<Long>();
      }
      this.trace_ids.add(elem);
    }

    public List<Long> getTrace_ids() {
      return this.trace_ids;
    }

    public getTracesByIds_args setTrace_ids(List<Long> trace_ids) {
      this.trace_ids = trace_ids;
      return this;
    }

    public void unsetTrace_ids() {
      this.trace_ids = null;
    }

    /** Returns true if field trace_ids is set (has been asigned a value) and false otherwise */
    public boolean isSetTrace_ids() {
      return this.trace_ids != null;
    }

    public void setTrace_idsIsSet(boolean value) {
      if (!value) {
        this.trace_ids = null;
      }
    }

    public int getAdjustSize() {
      return (this.adjust == null) ? 0 : this.adjust.size();
    }

    public java.util.Iterator<Adjust> getAdjustIterator() {
      return (this.adjust == null) ? null : this.adjust.iterator();
    }

    public void addToAdjust(Adjust elem) {
      if (this.adjust == null) {
        this.adjust = new ArrayList<Adjust>();
      }
      this.adjust.add(elem);
    }

    public List<Adjust> getAdjust() {
      return this.adjust;
    }

    public getTracesByIds_args setAdjust(List<Adjust> adjust) {
      this.adjust = adjust;
      return this;
    }

    public void unsetAdjust() {
      this.adjust = null;
    }

    /** Returns true if field adjust is set (has been asigned a value) and false otherwise */
    public boolean isSetAdjust() {
      return this.adjust != null;
    }

    public void setAdjustIsSet(boolean value) {
      if (!value) {
        this.adjust = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TRACE_IDS:
        if (value == null) {
          unsetTrace_ids();
        } else {
          setTrace_ids((List<Long>)value);
        }
        break;

      case ADJUST:
        if (value == null) {
          unsetAdjust();
        } else {
          setAdjust((List<Adjust>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TRACE_IDS:
        return getTrace_ids();

      case ADJUST:
        return getAdjust();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TRACE_IDS:
        return isSetTrace_ids();
      case ADJUST:
        return isSetAdjust();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTracesByIds_args)
        return this.equals((getTracesByIds_args)that);
      return false;
    }

    public boolean equals(getTracesByIds_args that) {
      if (that == null)
        return false;

      boolean this_present_trace_ids = true && this.isSetTrace_ids();
      boolean that_present_trace_ids = true && that.isSetTrace_ids();
      if (this_present_trace_ids || that_present_trace_ids) {
        if (!(this_present_trace_ids && that_present_trace_ids))
          return false;
        if (!this.trace_ids.equals(that.trace_ids))
          return false;
      }

      boolean this_present_adjust = true && this.isSetAdjust();
      boolean that_present_adjust = true && that.isSetAdjust();
      if (this_present_adjust || that_present_adjust) {
        if (!(this_present_adjust && that_present_adjust))
          return false;
        if (!this.adjust.equals(that.adjust))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTracesByIds_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTracesByIds_args typedOther = (getTracesByIds_args)other;

      lastComparison = Boolean.valueOf(isSetTrace_ids()).compareTo(typedOther.isSetTrace_ids());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTrace_ids()) {
        lastComparison = TBaseHelper.compareTo(this.trace_ids, typedOther.trace_ids);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetAdjust()).compareTo(typedOther.isSetAdjust());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetAdjust()) {
        lastComparison = TBaseHelper.compareTo(this.adjust, typedOther.adjust);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // TRACE_IDS
            if (field.type == TType.LIST) {
              {
                TList _list58 = iprot.readListBegin();
                this.trace_ids = new ArrayList<Long>(_list58.size);
                for (int _i59 = 0; _i59 < _list58.size; ++_i59)
                {
                  long _elem60;
                  _elem60 = iprot.readI64();
                  this.trace_ids.add(_elem60);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ADJUST
            if (field.type == TType.LIST) {
              {
                TList _list61 = iprot.readListBegin();
                this.adjust = new ArrayList<Adjust>(_list61.size);
                for (int _i62 = 0; _i62 < _list61.size; ++_i62)
                {
                  Adjust _elem63;
                  _elem63 = Adjust.findByValue(iprot.readI32());
                  this.adjust.add(_elem63);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.trace_ids != null) {
        oprot.writeFieldBegin(TRACE_IDS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.I64, this.trace_ids.size()));
          for (long _iter64 : this.trace_ids)
          {
            oprot.writeI64(_iter64);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      if (this.adjust != null) {
        oprot.writeFieldBegin(ADJUST_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.I32, this.adjust.size()));
          for (Adjust _iter65 : this.adjust)
          {
            oprot.writeI32(_iter65.getValue());
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTracesByIds_args(");
      boolean first = true;

      sb.append("trace_ids:");
      if (this.trace_ids == null) {
        sb.append("null");
      } else {
        sb.append(this.trace_ids);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("adjust:");
      if (this.adjust == null) {
        sb.append("null");
      } else {
        sb.append(this.adjust);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTracesByIds_result implements TBase<getTracesByIds_result, getTracesByIds_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTracesByIds_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField QE_FIELD_DESC = new TField("qe", TType.STRUCT, (short)1);

    public List<Trace> success;
    public QueryException qe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      QE((short)1, "qe");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // QE
            return QE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, Trace.class))));
      tmpMap.put(_Fields.QE, new FieldMetaData("qe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTracesByIds_result.class, metaDataMap);
    }

    public getTracesByIds_result() {
    }

    public getTracesByIds_result(
      List<Trace> success,
      QueryException qe)
    {
      this();
      this.success = success;
      this.qe = qe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTracesByIds_result(getTracesByIds_result other) {
      if (other.isSetSuccess()) {
        List<Trace> __this__success = new ArrayList<Trace>();
        for (Trace other_element : other.success) {
          __this__success.add(new Trace(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetQe()) {
        this.qe = new QueryException(other.qe);
      }
    }

    public getTracesByIds_result deepCopy() {
      return new getTracesByIds_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.qe = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<Trace> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(Trace elem) {
      if (this.success == null) {
        this.success = new ArrayList<Trace>();
      }
      this.success.add(elem);
    }

    public List<Trace> getSuccess() {
      return this.success;
    }

    public getTracesByIds_result setSuccess(List<Trace> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public QueryException getQe() {
      return this.qe;
    }

    public getTracesByIds_result setQe(QueryException qe) {
      this.qe = qe;
      return this;
    }

    public void unsetQe() {
      this.qe = null;
    }

    /** Returns true if field qe is set (has been asigned a value) and false otherwise */
    public boolean isSetQe() {
      return this.qe != null;
    }

    public void setQeIsSet(boolean value) {
      if (!value) {
        this.qe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<Trace>)value);
        }
        break;

      case QE:
        if (value == null) {
          unsetQe();
        } else {
          setQe((QueryException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case QE:
        return getQe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case QE:
        return isSetQe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTracesByIds_result)
        return this.equals((getTracesByIds_result)that);
      return false;
    }

    public boolean equals(getTracesByIds_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_qe = true && this.isSetQe();
      boolean that_present_qe = true && that.isSetQe();
      if (this_present_qe || that_present_qe) {
        if (!(this_present_qe && that_present_qe))
          return false;
        if (!this.qe.equals(that.qe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTracesByIds_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTracesByIds_result typedOther = (getTracesByIds_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetQe()).compareTo(typedOther.isSetQe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQe()) {
        lastComparison = TBaseHelper.compareTo(this.qe, typedOther.qe);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list66 = iprot.readListBegin();
                this.success = new ArrayList<Trace>(_list66.size);
                for (int _i67 = 0; _i67 < _list66.size; ++_i67)
                {
                  Trace _elem68;
                  _elem68 = new Trace();
                  _elem68.read(iprot);
                  this.success.add(_elem68);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // QE
            if (field.type == TType.STRUCT) {
              this.qe = new QueryException();
              this.qe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (Trace _iter69 : this.success)
          {
            _iter69.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetQe()) {
        oprot.writeFieldBegin(QE_FIELD_DESC);
        this.qe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTracesByIds_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("qe:");
      if (this.qe == null) {
        sb.append("null");
      } else {
        sb.append(this.qe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTraceTimelinesByIds_args implements TBase<getTraceTimelinesByIds_args, getTraceTimelinesByIds_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTraceTimelinesByIds_args");

    private static final TField TRACE_IDS_FIELD_DESC = new TField("trace_ids", TType.LIST, (short)1);
    private static final TField ADJUST_FIELD_DESC = new TField("adjust", TType.LIST, (short)2);

    public List<Long> trace_ids;
    public List<Adjust> adjust;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TRACE_IDS((short)1, "trace_ids"),
      ADJUST((short)2, "adjust");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TRACE_IDS
            return TRACE_IDS;
          case 2: // ADJUST
            return ADJUST;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TRACE_IDS, new FieldMetaData("trace_ids", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.I64))));
      tmpMap.put(_Fields.ADJUST, new FieldMetaData("adjust", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new EnumMetaData(TType.ENUM, Adjust.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTraceTimelinesByIds_args.class, metaDataMap);
    }

    public getTraceTimelinesByIds_args() {
    }

    public getTraceTimelinesByIds_args(
      List<Long> trace_ids,
      List<Adjust> adjust)
    {
      this();
      this.trace_ids = trace_ids;
      this.adjust = adjust;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTraceTimelinesByIds_args(getTraceTimelinesByIds_args other) {
      if (other.isSetTrace_ids()) {
        List<Long> __this__trace_ids = new ArrayList<Long>();
        for (Long other_element : other.trace_ids) {
          __this__trace_ids.add(other_element);
        }
        this.trace_ids = __this__trace_ids;
      }
      if (other.isSetAdjust()) {
        List<Adjust> __this__adjust = new ArrayList<Adjust>();
        for (Adjust other_element : other.adjust) {
          __this__adjust.add(other_element);
        }
        this.adjust = __this__adjust;
      }
    }

    public getTraceTimelinesByIds_args deepCopy() {
      return new getTraceTimelinesByIds_args(this);
    }

    @Override
    public void clear() {
      this.trace_ids = null;
      this.adjust = null;
    }

    public int getTrace_idsSize() {
      return (this.trace_ids == null) ? 0 : this.trace_ids.size();
    }

    public java.util.Iterator<Long> getTrace_idsIterator() {
      return (this.trace_ids == null) ? null : this.trace_ids.iterator();
    }

    public void addToTrace_ids(long elem) {
      if (this.trace_ids == null) {
        this.trace_ids = new ArrayList<Long>();
      }
      this.trace_ids.add(elem);
    }

    public List<Long> getTrace_ids() {
      return this.trace_ids;
    }

    public getTraceTimelinesByIds_args setTrace_ids(List<Long> trace_ids) {
      this.trace_ids = trace_ids;
      return this;
    }

    public void unsetTrace_ids() {
      this.trace_ids = null;
    }

    /** Returns true if field trace_ids is set (has been asigned a value) and false otherwise */
    public boolean isSetTrace_ids() {
      return this.trace_ids != null;
    }

    public void setTrace_idsIsSet(boolean value) {
      if (!value) {
        this.trace_ids = null;
      }
    }

    public int getAdjustSize() {
      return (this.adjust == null) ? 0 : this.adjust.size();
    }

    public java.util.Iterator<Adjust> getAdjustIterator() {
      return (this.adjust == null) ? null : this.adjust.iterator();
    }

    public void addToAdjust(Adjust elem) {
      if (this.adjust == null) {
        this.adjust = new ArrayList<Adjust>();
      }
      this.adjust.add(elem);
    }

    public List<Adjust> getAdjust() {
      return this.adjust;
    }

    public getTraceTimelinesByIds_args setAdjust(List<Adjust> adjust) {
      this.adjust = adjust;
      return this;
    }

    public void unsetAdjust() {
      this.adjust = null;
    }

    /** Returns true if field adjust is set (has been asigned a value) and false otherwise */
    public boolean isSetAdjust() {
      return this.adjust != null;
    }

    public void setAdjustIsSet(boolean value) {
      if (!value) {
        this.adjust = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TRACE_IDS:
        if (value == null) {
          unsetTrace_ids();
        } else {
          setTrace_ids((List<Long>)value);
        }
        break;

      case ADJUST:
        if (value == null) {
          unsetAdjust();
        } else {
          setAdjust((List<Adjust>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TRACE_IDS:
        return getTrace_ids();

      case ADJUST:
        return getAdjust();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TRACE_IDS:
        return isSetTrace_ids();
      case ADJUST:
        return isSetAdjust();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTraceTimelinesByIds_args)
        return this.equals((getTraceTimelinesByIds_args)that);
      return false;
    }

    public boolean equals(getTraceTimelinesByIds_args that) {
      if (that == null)
        return false;

      boolean this_present_trace_ids = true && this.isSetTrace_ids();
      boolean that_present_trace_ids = true && that.isSetTrace_ids();
      if (this_present_trace_ids || that_present_trace_ids) {
        if (!(this_present_trace_ids && that_present_trace_ids))
          return false;
        if (!this.trace_ids.equals(that.trace_ids))
          return false;
      }

      boolean this_present_adjust = true && this.isSetAdjust();
      boolean that_present_adjust = true && that.isSetAdjust();
      if (this_present_adjust || that_present_adjust) {
        if (!(this_present_adjust && that_present_adjust))
          return false;
        if (!this.adjust.equals(that.adjust))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTraceTimelinesByIds_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTraceTimelinesByIds_args typedOther = (getTraceTimelinesByIds_args)other;

      lastComparison = Boolean.valueOf(isSetTrace_ids()).compareTo(typedOther.isSetTrace_ids());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTrace_ids()) {
        lastComparison = TBaseHelper.compareTo(this.trace_ids, typedOther.trace_ids);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetAdjust()).compareTo(typedOther.isSetAdjust());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetAdjust()) {
        lastComparison = TBaseHelper.compareTo(this.adjust, typedOther.adjust);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // TRACE_IDS
            if (field.type == TType.LIST) {
              {
                TList _list70 = iprot.readListBegin();
                this.trace_ids = new ArrayList<Long>(_list70.size);
                for (int _i71 = 0; _i71 < _list70.size; ++_i71)
                {
                  long _elem72;
                  _elem72 = iprot.readI64();
                  this.trace_ids.add(_elem72);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ADJUST
            if (field.type == TType.LIST) {
              {
                TList _list73 = iprot.readListBegin();
                this.adjust = new ArrayList<Adjust>(_list73.size);
                for (int _i74 = 0; _i74 < _list73.size; ++_i74)
                {
                  Adjust _elem75;
                  _elem75 = Adjust.findByValue(iprot.readI32());
                  this.adjust.add(_elem75);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.trace_ids != null) {
        oprot.writeFieldBegin(TRACE_IDS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.I64, this.trace_ids.size()));
          for (long _iter76 : this.trace_ids)
          {
            oprot.writeI64(_iter76);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      if (this.adjust != null) {
        oprot.writeFieldBegin(ADJUST_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.I32, this.adjust.size()));
          for (Adjust _iter77 : this.adjust)
          {
            oprot.writeI32(_iter77.getValue());
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTraceTimelinesByIds_args(");
      boolean first = true;

      sb.append("trace_ids:");
      if (this.trace_ids == null) {
        sb.append("null");
      } else {
        sb.append(this.trace_ids);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("adjust:");
      if (this.adjust == null) {
        sb.append("null");
      } else {
        sb.append(this.adjust);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTraceTimelinesByIds_result implements TBase<getTraceTimelinesByIds_result, getTraceTimelinesByIds_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTraceTimelinesByIds_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField QE_FIELD_DESC = new TField("qe", TType.STRUCT, (short)1);

    public List<TraceTimeline> success;
    public QueryException qe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      QE((short)1, "qe");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // QE
            return QE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, TraceTimeline.class))));
      tmpMap.put(_Fields.QE, new FieldMetaData("qe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTraceTimelinesByIds_result.class, metaDataMap);
    }

    public getTraceTimelinesByIds_result() {
    }

    public getTraceTimelinesByIds_result(
      List<TraceTimeline> success,
      QueryException qe)
    {
      this();
      this.success = success;
      this.qe = qe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTraceTimelinesByIds_result(getTraceTimelinesByIds_result other) {
      if (other.isSetSuccess()) {
        List<TraceTimeline> __this__success = new ArrayList<TraceTimeline>();
        for (TraceTimeline other_element : other.success) {
          __this__success.add(new TraceTimeline(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetQe()) {
        this.qe = new QueryException(other.qe);
      }
    }

    public getTraceTimelinesByIds_result deepCopy() {
      return new getTraceTimelinesByIds_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.qe = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<TraceTimeline> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(TraceTimeline elem) {
      if (this.success == null) {
        this.success = new ArrayList<TraceTimeline>();
      }
      this.success.add(elem);
    }

    public List<TraceTimeline> getSuccess() {
      return this.success;
    }

    public getTraceTimelinesByIds_result setSuccess(List<TraceTimeline> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public QueryException getQe() {
      return this.qe;
    }

    public getTraceTimelinesByIds_result setQe(QueryException qe) {
      this.qe = qe;
      return this;
    }

    public void unsetQe() {
      this.qe = null;
    }

    /** Returns true if field qe is set (has been asigned a value) and false otherwise */
    public boolean isSetQe() {
      return this.qe != null;
    }

    public void setQeIsSet(boolean value) {
      if (!value) {
        this.qe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<TraceTimeline>)value);
        }
        break;

      case QE:
        if (value == null) {
          unsetQe();
        } else {
          setQe((QueryException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case QE:
        return getQe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case QE:
        return isSetQe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTraceTimelinesByIds_result)
        return this.equals((getTraceTimelinesByIds_result)that);
      return false;
    }

    public boolean equals(getTraceTimelinesByIds_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_qe = true && this.isSetQe();
      boolean that_present_qe = true && that.isSetQe();
      if (this_present_qe || that_present_qe) {
        if (!(this_present_qe && that_present_qe))
          return false;
        if (!this.qe.equals(that.qe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTraceTimelinesByIds_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTraceTimelinesByIds_result typedOther = (getTraceTimelinesByIds_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetQe()).compareTo(typedOther.isSetQe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQe()) {
        lastComparison = TBaseHelper.compareTo(this.qe, typedOther.qe);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list78 = iprot.readListBegin();
                this.success = new ArrayList<TraceTimeline>(_list78.size);
                for (int _i79 = 0; _i79 < _list78.size; ++_i79)
                {
                  TraceTimeline _elem80;
                  _elem80 = new TraceTimeline();
                  _elem80.read(iprot);
                  this.success.add(_elem80);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // QE
            if (field.type == TType.STRUCT) {
              this.qe = new QueryException();
              this.qe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (TraceTimeline _iter81 : this.success)
          {
            _iter81.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetQe()) {
        oprot.writeFieldBegin(QE_FIELD_DESC);
        this.qe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTraceTimelinesByIds_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("qe:");
      if (this.qe == null) {
        sb.append("null");
      } else {
        sb.append(this.qe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTraceSummariesByIds_args implements TBase<getTraceSummariesByIds_args, getTraceSummariesByIds_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTraceSummariesByIds_args");

    private static final TField TRACE_IDS_FIELD_DESC = new TField("trace_ids", TType.LIST, (short)1);
    private static final TField ADJUST_FIELD_DESC = new TField("adjust", TType.LIST, (short)2);

    public List<Long> trace_ids;
    public List<Adjust> adjust;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TRACE_IDS((short)1, "trace_ids"),
      ADJUST((short)2, "adjust");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TRACE_IDS
            return TRACE_IDS;
          case 2: // ADJUST
            return ADJUST;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TRACE_IDS, new FieldMetaData("trace_ids", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.I64))));
      tmpMap.put(_Fields.ADJUST, new FieldMetaData("adjust", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new EnumMetaData(TType.ENUM, Adjust.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTraceSummariesByIds_args.class, metaDataMap);
    }

    public getTraceSummariesByIds_args() {
    }

    public getTraceSummariesByIds_args(
      List<Long> trace_ids,
      List<Adjust> adjust)
    {
      this();
      this.trace_ids = trace_ids;
      this.adjust = adjust;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTraceSummariesByIds_args(getTraceSummariesByIds_args other) {
      if (other.isSetTrace_ids()) {
        List<Long> __this__trace_ids = new ArrayList<Long>();
        for (Long other_element : other.trace_ids) {
          __this__trace_ids.add(other_element);
        }
        this.trace_ids = __this__trace_ids;
      }
      if (other.isSetAdjust()) {
        List<Adjust> __this__adjust = new ArrayList<Adjust>();
        for (Adjust other_element : other.adjust) {
          __this__adjust.add(other_element);
        }
        this.adjust = __this__adjust;
      }
    }

    public getTraceSummariesByIds_args deepCopy() {
      return new getTraceSummariesByIds_args(this);
    }

    @Override
    public void clear() {
      this.trace_ids = null;
      this.adjust = null;
    }

    public int getTrace_idsSize() {
      return (this.trace_ids == null) ? 0 : this.trace_ids.size();
    }

    public java.util.Iterator<Long> getTrace_idsIterator() {
      return (this.trace_ids == null) ? null : this.trace_ids.iterator();
    }

    public void addToTrace_ids(long elem) {
      if (this.trace_ids == null) {
        this.trace_ids = new ArrayList<Long>();
      }
      this.trace_ids.add(elem);
    }

    public List<Long> getTrace_ids() {
      return this.trace_ids;
    }

    public getTraceSummariesByIds_args setTrace_ids(List<Long> trace_ids) {
      this.trace_ids = trace_ids;
      return this;
    }

    public void unsetTrace_ids() {
      this.trace_ids = null;
    }

    /** Returns true if field trace_ids is set (has been asigned a value) and false otherwise */
    public boolean isSetTrace_ids() {
      return this.trace_ids != null;
    }

    public void setTrace_idsIsSet(boolean value) {
      if (!value) {
        this.trace_ids = null;
      }
    }

    public int getAdjustSize() {
      return (this.adjust == null) ? 0 : this.adjust.size();
    }

    public java.util.Iterator<Adjust> getAdjustIterator() {
      return (this.adjust == null) ? null : this.adjust.iterator();
    }

    public void addToAdjust(Adjust elem) {
      if (this.adjust == null) {
        this.adjust = new ArrayList<Adjust>();
      }
      this.adjust.add(elem);
    }

    public List<Adjust> getAdjust() {
      return this.adjust;
    }

    public getTraceSummariesByIds_args setAdjust(List<Adjust> adjust) {
      this.adjust = adjust;
      return this;
    }

    public void unsetAdjust() {
      this.adjust = null;
    }

    /** Returns true if field adjust is set (has been asigned a value) and false otherwise */
    public boolean isSetAdjust() {
      return this.adjust != null;
    }

    public void setAdjustIsSet(boolean value) {
      if (!value) {
        this.adjust = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TRACE_IDS:
        if (value == null) {
          unsetTrace_ids();
        } else {
          setTrace_ids((List<Long>)value);
        }
        break;

      case ADJUST:
        if (value == null) {
          unsetAdjust();
        } else {
          setAdjust((List<Adjust>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TRACE_IDS:
        return getTrace_ids();

      case ADJUST:
        return getAdjust();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TRACE_IDS:
        return isSetTrace_ids();
      case ADJUST:
        return isSetAdjust();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTraceSummariesByIds_args)
        return this.equals((getTraceSummariesByIds_args)that);
      return false;
    }

    public boolean equals(getTraceSummariesByIds_args that) {
      if (that == null)
        return false;

      boolean this_present_trace_ids = true && this.isSetTrace_ids();
      boolean that_present_trace_ids = true && that.isSetTrace_ids();
      if (this_present_trace_ids || that_present_trace_ids) {
        if (!(this_present_trace_ids && that_present_trace_ids))
          return false;
        if (!this.trace_ids.equals(that.trace_ids))
          return false;
      }

      boolean this_present_adjust = true && this.isSetAdjust();
      boolean that_present_adjust = true && that.isSetAdjust();
      if (this_present_adjust || that_present_adjust) {
        if (!(this_present_adjust && that_present_adjust))
          return false;
        if (!this.adjust.equals(that.adjust))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTraceSummariesByIds_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTraceSummariesByIds_args typedOther = (getTraceSummariesByIds_args)other;

      lastComparison = Boolean.valueOf(isSetTrace_ids()).compareTo(typedOther.isSetTrace_ids());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTrace_ids()) {
        lastComparison = TBaseHelper.compareTo(this.trace_ids, typedOther.trace_ids);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetAdjust()).compareTo(typedOther.isSetAdjust());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetAdjust()) {
        lastComparison = TBaseHelper.compareTo(this.adjust, typedOther.adjust);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // TRACE_IDS
            if (field.type == TType.LIST) {
              {
                TList _list82 = iprot.readListBegin();
                this.trace_ids = new ArrayList<Long>(_list82.size);
                for (int _i83 = 0; _i83 < _list82.size; ++_i83)
                {
                  long _elem84;
                  _elem84 = iprot.readI64();
                  this.trace_ids.add(_elem84);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ADJUST
            if (field.type == TType.LIST) {
              {
                TList _list85 = iprot.readListBegin();
                this.adjust = new ArrayList<Adjust>(_list85.size);
                for (int _i86 = 0; _i86 < _list85.size; ++_i86)
                {
                  Adjust _elem87;
                  _elem87 = Adjust.findByValue(iprot.readI32());
                  this.adjust.add(_elem87);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.trace_ids != null) {
        oprot.writeFieldBegin(TRACE_IDS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.I64, this.trace_ids.size()));
          for (long _iter88 : this.trace_ids)
          {
            oprot.writeI64(_iter88);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      if (this.adjust != null) {
        oprot.writeFieldBegin(ADJUST_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.I32, this.adjust.size()));
          for (Adjust _iter89 : this.adjust)
          {
            oprot.writeI32(_iter89.getValue());
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTraceSummariesByIds_args(");
      boolean first = true;

      sb.append("trace_ids:");
      if (this.trace_ids == null) {
        sb.append("null");
      } else {
        sb.append(this.trace_ids);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("adjust:");
      if (this.adjust == null) {
        sb.append("null");
      } else {
        sb.append(this.adjust);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTraceSummariesByIds_result implements TBase<getTraceSummariesByIds_result, getTraceSummariesByIds_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTraceSummariesByIds_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField QE_FIELD_DESC = new TField("qe", TType.STRUCT, (short)1);

    public List<TraceSummary> success;
    public QueryException qe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      QE((short)1, "qe");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // QE
            return QE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, TraceSummary.class))));
      tmpMap.put(_Fields.QE, new FieldMetaData("qe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTraceSummariesByIds_result.class, metaDataMap);
    }

    public getTraceSummariesByIds_result() {
    }

    public getTraceSummariesByIds_result(
      List<TraceSummary> success,
      QueryException qe)
    {
      this();
      this.success = success;
      this.qe = qe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTraceSummariesByIds_result(getTraceSummariesByIds_result other) {
      if (other.isSetSuccess()) {
        List<TraceSummary> __this__success = new ArrayList<TraceSummary>();
        for (TraceSummary other_element : other.success) {
          __this__success.add(new TraceSummary(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetQe()) {
        this.qe = new QueryException(other.qe);
      }
    }

    public getTraceSummariesByIds_result deepCopy() {
      return new getTraceSummariesByIds_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.qe = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<TraceSummary> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(TraceSummary elem) {
      if (this.success == null) {
        this.success = new ArrayList<TraceSummary>();
      }
      this.success.add(elem);
    }

    public List<TraceSummary> getSuccess() {
      return this.success;
    }

    public getTraceSummariesByIds_result setSuccess(List<TraceSummary> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public QueryException getQe() {
      return this.qe;
    }

    public getTraceSummariesByIds_result setQe(QueryException qe) {
      this.qe = qe;
      return this;
    }

    public void unsetQe() {
      this.qe = null;
    }

    /** Returns true if field qe is set (has been asigned a value) and false otherwise */
    public boolean isSetQe() {
      return this.qe != null;
    }

    public void setQeIsSet(boolean value) {
      if (!value) {
        this.qe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<TraceSummary>)value);
        }
        break;

      case QE:
        if (value == null) {
          unsetQe();
        } else {
          setQe((QueryException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case QE:
        return getQe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case QE:
        return isSetQe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTraceSummariesByIds_result)
        return this.equals((getTraceSummariesByIds_result)that);
      return false;
    }

    public boolean equals(getTraceSummariesByIds_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_qe = true && this.isSetQe();
      boolean that_present_qe = true && that.isSetQe();
      if (this_present_qe || that_present_qe) {
        if (!(this_present_qe && that_present_qe))
          return false;
        if (!this.qe.equals(that.qe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTraceSummariesByIds_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTraceSummariesByIds_result typedOther = (getTraceSummariesByIds_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetQe()).compareTo(typedOther.isSetQe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQe()) {
        lastComparison = TBaseHelper.compareTo(this.qe, typedOther.qe);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list90 = iprot.readListBegin();
                this.success = new ArrayList<TraceSummary>(_list90.size);
                for (int _i91 = 0; _i91 < _list90.size; ++_i91)
                {
                  TraceSummary _elem92;
                  _elem92 = new TraceSummary();
                  _elem92.read(iprot);
                  this.success.add(_elem92);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // QE
            if (field.type == TType.STRUCT) {
              this.qe = new QueryException();
              this.qe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (TraceSummary _iter93 : this.success)
          {
            _iter93.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetQe()) {
        oprot.writeFieldBegin(QE_FIELD_DESC);
        this.qe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTraceSummariesByIds_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("qe:");
      if (this.qe == null) {
        sb.append("null");
      } else {
        sb.append(this.qe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTraceCombosByIds_args implements TBase<getTraceCombosByIds_args, getTraceCombosByIds_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTraceCombosByIds_args");

    private static final TField TRACE_IDS_FIELD_DESC = new TField("trace_ids", TType.LIST, (short)1);
    private static final TField ADJUST_FIELD_DESC = new TField("adjust", TType.LIST, (short)2);

    public List<Long> trace_ids;
    public List<Adjust> adjust;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TRACE_IDS((short)1, "trace_ids"),
      ADJUST((short)2, "adjust");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TRACE_IDS
            return TRACE_IDS;
          case 2: // ADJUST
            return ADJUST;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TRACE_IDS, new FieldMetaData("trace_ids", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.I64))));
      tmpMap.put(_Fields.ADJUST, new FieldMetaData("adjust", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new EnumMetaData(TType.ENUM, Adjust.class))));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTraceCombosByIds_args.class, metaDataMap);
    }

    public getTraceCombosByIds_args() {
    }

    public getTraceCombosByIds_args(
      List<Long> trace_ids,
      List<Adjust> adjust)
    {
      this();
      this.trace_ids = trace_ids;
      this.adjust = adjust;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTraceCombosByIds_args(getTraceCombosByIds_args other) {
      if (other.isSetTrace_ids()) {
        List<Long> __this__trace_ids = new ArrayList<Long>();
        for (Long other_element : other.trace_ids) {
          __this__trace_ids.add(other_element);
        }
        this.trace_ids = __this__trace_ids;
      }
      if (other.isSetAdjust()) {
        List<Adjust> __this__adjust = new ArrayList<Adjust>();
        for (Adjust other_element : other.adjust) {
          __this__adjust.add(other_element);
        }
        this.adjust = __this__adjust;
      }
    }

    public getTraceCombosByIds_args deepCopy() {
      return new getTraceCombosByIds_args(this);
    }

    @Override
    public void clear() {
      this.trace_ids = null;
      this.adjust = null;
    }

    public int getTrace_idsSize() {
      return (this.trace_ids == null) ? 0 : this.trace_ids.size();
    }

    public java.util.Iterator<Long> getTrace_idsIterator() {
      return (this.trace_ids == null) ? null : this.trace_ids.iterator();
    }

    public void addToTrace_ids(long elem) {
      if (this.trace_ids == null) {
        this.trace_ids = new ArrayList<Long>();
      }
      this.trace_ids.add(elem);
    }

    public List<Long> getTrace_ids() {
      return this.trace_ids;
    }

    public getTraceCombosByIds_args setTrace_ids(List<Long> trace_ids) {
      this.trace_ids = trace_ids;
      return this;
    }

    public void unsetTrace_ids() {
      this.trace_ids = null;
    }

    /** Returns true if field trace_ids is set (has been asigned a value) and false otherwise */
    public boolean isSetTrace_ids() {
      return this.trace_ids != null;
    }

    public void setTrace_idsIsSet(boolean value) {
      if (!value) {
        this.trace_ids = null;
      }
    }

    public int getAdjustSize() {
      return (this.adjust == null) ? 0 : this.adjust.size();
    }

    public java.util.Iterator<Adjust> getAdjustIterator() {
      return (this.adjust == null) ? null : this.adjust.iterator();
    }

    public void addToAdjust(Adjust elem) {
      if (this.adjust == null) {
        this.adjust = new ArrayList<Adjust>();
      }
      this.adjust.add(elem);
    }

    public List<Adjust> getAdjust() {
      return this.adjust;
    }

    public getTraceCombosByIds_args setAdjust(List<Adjust> adjust) {
      this.adjust = adjust;
      return this;
    }

    public void unsetAdjust() {
      this.adjust = null;
    }

    /** Returns true if field adjust is set (has been asigned a value) and false otherwise */
    public boolean isSetAdjust() {
      return this.adjust != null;
    }

    public void setAdjustIsSet(boolean value) {
      if (!value) {
        this.adjust = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TRACE_IDS:
        if (value == null) {
          unsetTrace_ids();
        } else {
          setTrace_ids((List<Long>)value);
        }
        break;

      case ADJUST:
        if (value == null) {
          unsetAdjust();
        } else {
          setAdjust((List<Adjust>)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TRACE_IDS:
        return getTrace_ids();

      case ADJUST:
        return getAdjust();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TRACE_IDS:
        return isSetTrace_ids();
      case ADJUST:
        return isSetAdjust();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTraceCombosByIds_args)
        return this.equals((getTraceCombosByIds_args)that);
      return false;
    }

    public boolean equals(getTraceCombosByIds_args that) {
      if (that == null)
        return false;

      boolean this_present_trace_ids = true && this.isSetTrace_ids();
      boolean that_present_trace_ids = true && that.isSetTrace_ids();
      if (this_present_trace_ids || that_present_trace_ids) {
        if (!(this_present_trace_ids && that_present_trace_ids))
          return false;
        if (!this.trace_ids.equals(that.trace_ids))
          return false;
      }

      boolean this_present_adjust = true && this.isSetAdjust();
      boolean that_present_adjust = true && that.isSetAdjust();
      if (this_present_adjust || that_present_adjust) {
        if (!(this_present_adjust && that_present_adjust))
          return false;
        if (!this.adjust.equals(that.adjust))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTraceCombosByIds_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTraceCombosByIds_args typedOther = (getTraceCombosByIds_args)other;

      lastComparison = Boolean.valueOf(isSetTrace_ids()).compareTo(typedOther.isSetTrace_ids());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTrace_ids()) {
        lastComparison = TBaseHelper.compareTo(this.trace_ids, typedOther.trace_ids);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetAdjust()).compareTo(typedOther.isSetAdjust());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetAdjust()) {
        lastComparison = TBaseHelper.compareTo(this.adjust, typedOther.adjust);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // TRACE_IDS
            if (field.type == TType.LIST) {
              {
                TList _list94 = iprot.readListBegin();
                this.trace_ids = new ArrayList<Long>(_list94.size);
                for (int _i95 = 0; _i95 < _list94.size; ++_i95)
                {
                  long _elem96;
                  _elem96 = iprot.readI64();
                  this.trace_ids.add(_elem96);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // ADJUST
            if (field.type == TType.LIST) {
              {
                TList _list97 = iprot.readListBegin();
                this.adjust = new ArrayList<Adjust>(_list97.size);
                for (int _i98 = 0; _i98 < _list97.size; ++_i98)
                {
                  Adjust _elem99;
                  _elem99 = Adjust.findByValue(iprot.readI32());
                  this.adjust.add(_elem99);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.trace_ids != null) {
        oprot.writeFieldBegin(TRACE_IDS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.I64, this.trace_ids.size()));
          for (long _iter100 : this.trace_ids)
          {
            oprot.writeI64(_iter100);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      if (this.adjust != null) {
        oprot.writeFieldBegin(ADJUST_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.I32, this.adjust.size()));
          for (Adjust _iter101 : this.adjust)
          {
            oprot.writeI32(_iter101.getValue());
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTraceCombosByIds_args(");
      boolean first = true;

      sb.append("trace_ids:");
      if (this.trace_ids == null) {
        sb.append("null");
      } else {
        sb.append(this.trace_ids);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("adjust:");
      if (this.adjust == null) {
        sb.append("null");
      } else {
        sb.append(this.adjust);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTraceCombosByIds_result implements TBase<getTraceCombosByIds_result, getTraceCombosByIds_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTraceCombosByIds_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField QE_FIELD_DESC = new TField("qe", TType.STRUCT, (short)1);

    public List<TraceCombo> success;
    public QueryException qe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      QE((short)1, "qe");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // QE
            return QE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new StructMetaData(TType.STRUCT, TraceCombo.class))));
      tmpMap.put(_Fields.QE, new FieldMetaData("qe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTraceCombosByIds_result.class, metaDataMap);
    }

    public getTraceCombosByIds_result() {
    }

    public getTraceCombosByIds_result(
      List<TraceCombo> success,
      QueryException qe)
    {
      this();
      this.success = success;
      this.qe = qe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTraceCombosByIds_result(getTraceCombosByIds_result other) {
      if (other.isSetSuccess()) {
        List<TraceCombo> __this__success = new ArrayList<TraceCombo>();
        for (TraceCombo other_element : other.success) {
          __this__success.add(new TraceCombo(other_element));
        }
        this.success = __this__success;
      }
      if (other.isSetQe()) {
        this.qe = new QueryException(other.qe);
      }
    }

    public getTraceCombosByIds_result deepCopy() {
      return new getTraceCombosByIds_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.qe = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<TraceCombo> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(TraceCombo elem) {
      if (this.success == null) {
        this.success = new ArrayList<TraceCombo>();
      }
      this.success.add(elem);
    }

    public List<TraceCombo> getSuccess() {
      return this.success;
    }

    public getTraceCombosByIds_result setSuccess(List<TraceCombo> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public QueryException getQe() {
      return this.qe;
    }

    public getTraceCombosByIds_result setQe(QueryException qe) {
      this.qe = qe;
      return this;
    }

    public void unsetQe() {
      this.qe = null;
    }

    /** Returns true if field qe is set (has been asigned a value) and false otherwise */
    public boolean isSetQe() {
      return this.qe != null;
    }

    public void setQeIsSet(boolean value) {
      if (!value) {
        this.qe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<TraceCombo>)value);
        }
        break;

      case QE:
        if (value == null) {
          unsetQe();
        } else {
          setQe((QueryException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case QE:
        return getQe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case QE:
        return isSetQe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTraceCombosByIds_result)
        return this.equals((getTraceCombosByIds_result)that);
      return false;
    }

    public boolean equals(getTraceCombosByIds_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_qe = true && this.isSetQe();
      boolean that_present_qe = true && that.isSetQe();
      if (this_present_qe || that_present_qe) {
        if (!(this_present_qe && that_present_qe))
          return false;
        if (!this.qe.equals(that.qe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTraceCombosByIds_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTraceCombosByIds_result typedOther = (getTraceCombosByIds_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetQe()).compareTo(typedOther.isSetQe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQe()) {
        lastComparison = TBaseHelper.compareTo(this.qe, typedOther.qe);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list102 = iprot.readListBegin();
                this.success = new ArrayList<TraceCombo>(_list102.size);
                for (int _i103 = 0; _i103 < _list102.size; ++_i103)
                {
                  TraceCombo _elem104;
                  _elem104 = new TraceCombo();
                  _elem104.read(iprot);
                  this.success.add(_elem104);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // QE
            if (field.type == TType.STRUCT) {
              this.qe = new QueryException();
              this.qe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRUCT, this.success.size()));
          for (TraceCombo _iter105 : this.success)
          {
            _iter105.write(oprot);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetQe()) {
        oprot.writeFieldBegin(QE_FIELD_DESC);
        this.qe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTraceCombosByIds_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("qe:");
      if (this.qe == null) {
        sb.append("null");
      } else {
        sb.append(this.qe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getServiceNames_args implements TBase<getServiceNames_args, getServiceNames_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getServiceNames_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getServiceNames_args.class, metaDataMap);
    }

    public getServiceNames_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getServiceNames_args(getServiceNames_args other) {
    }

    public getServiceNames_args deepCopy() {
      return new getServiceNames_args(this);
    }

    @Override
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getServiceNames_args)
        return this.equals((getServiceNames_args)that);
      return false;
    }

    public boolean equals(getServiceNames_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getServiceNames_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getServiceNames_args typedOther = (getServiceNames_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getServiceNames_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getServiceNames_result implements TBase<getServiceNames_result, getServiceNames_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getServiceNames_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.SET, (short)0);
    private static final TField QE_FIELD_DESC = new TField("qe", TType.STRUCT, (short)1);

    public Set<String> success;
    public QueryException qe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      QE((short)1, "qe");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // QE
            return QE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new SetMetaData(TType.SET, 
              new FieldValueMetaData(TType.STRING))));
      tmpMap.put(_Fields.QE, new FieldMetaData("qe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getServiceNames_result.class, metaDataMap);
    }

    public getServiceNames_result() {
    }

    public getServiceNames_result(
      Set<String> success,
      QueryException qe)
    {
      this();
      this.success = success;
      this.qe = qe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getServiceNames_result(getServiceNames_result other) {
      if (other.isSetSuccess()) {
        Set<String> __this__success = new HashSet<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetQe()) {
        this.qe = new QueryException(other.qe);
      }
    }

    public getServiceNames_result deepCopy() {
      return new getServiceNames_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.qe = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new HashSet<String>();
      }
      this.success.add(elem);
    }

    public Set<String> getSuccess() {
      return this.success;
    }

    public getServiceNames_result setSuccess(Set<String> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public QueryException getQe() {
      return this.qe;
    }

    public getServiceNames_result setQe(QueryException qe) {
      this.qe = qe;
      return this;
    }

    public void unsetQe() {
      this.qe = null;
    }

    /** Returns true if field qe is set (has been asigned a value) and false otherwise */
    public boolean isSetQe() {
      return this.qe != null;
    }

    public void setQeIsSet(boolean value) {
      if (!value) {
        this.qe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Set<String>)value);
        }
        break;

      case QE:
        if (value == null) {
          unsetQe();
        } else {
          setQe((QueryException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case QE:
        return getQe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case QE:
        return isSetQe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getServiceNames_result)
        return this.equals((getServiceNames_result)that);
      return false;
    }

    public boolean equals(getServiceNames_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_qe = true && this.isSetQe();
      boolean that_present_qe = true && that.isSetQe();
      if (this_present_qe || that_present_qe) {
        if (!(this_present_qe && that_present_qe))
          return false;
        if (!this.qe.equals(that.qe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getServiceNames_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getServiceNames_result typedOther = (getServiceNames_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetQe()).compareTo(typedOther.isSetQe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQe()) {
        lastComparison = TBaseHelper.compareTo(this.qe, typedOther.qe);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.SET) {
              {
                TSet _set106 = iprot.readSetBegin();
                this.success = new HashSet<String>(2*_set106.size);
                for (int _i107 = 0; _i107 < _set106.size; ++_i107)
                {
                  String _elem108;
                  _elem108 = iprot.readString();
                  this.success.add(_elem108);
                }
                iprot.readSetEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // QE
            if (field.type == TType.STRUCT) {
              this.qe = new QueryException();
              this.qe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeSetBegin(new TSet(TType.STRING, this.success.size()));
          for (String _iter109 : this.success)
          {
            oprot.writeString(_iter109);
          }
          oprot.writeSetEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetQe()) {
        oprot.writeFieldBegin(QE_FIELD_DESC);
        this.qe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getServiceNames_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("qe:");
      if (this.qe == null) {
        sb.append("null");
      } else {
        sb.append(this.qe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getSpanNames_args implements TBase<getSpanNames_args, getSpanNames_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getSpanNames_args");

    private static final TField SERVICE_NAME_FIELD_DESC = new TField("service_name", TType.STRING, (short)1);

    public String service_name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SERVICE_NAME((short)1, "service_name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SERVICE_NAME
            return SERVICE_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SERVICE_NAME, new FieldMetaData("service_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getSpanNames_args.class, metaDataMap);
    }

    public getSpanNames_args() {
    }

    public getSpanNames_args(
      String service_name)
    {
      this();
      this.service_name = service_name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getSpanNames_args(getSpanNames_args other) {
      if (other.isSetService_name()) {
        this.service_name = other.service_name;
      }
    }

    public getSpanNames_args deepCopy() {
      return new getSpanNames_args(this);
    }

    @Override
    public void clear() {
      this.service_name = null;
    }

    public String getService_name() {
      return this.service_name;
    }

    public getSpanNames_args setService_name(String service_name) {
      this.service_name = service_name;
      return this;
    }

    public void unsetService_name() {
      this.service_name = null;
    }

    /** Returns true if field service_name is set (has been asigned a value) and false otherwise */
    public boolean isSetService_name() {
      return this.service_name != null;
    }

    public void setService_nameIsSet(boolean value) {
      if (!value) {
        this.service_name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SERVICE_NAME:
        if (value == null) {
          unsetService_name();
        } else {
          setService_name((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SERVICE_NAME:
        return getService_name();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SERVICE_NAME:
        return isSetService_name();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getSpanNames_args)
        return this.equals((getSpanNames_args)that);
      return false;
    }

    public boolean equals(getSpanNames_args that) {
      if (that == null)
        return false;

      boolean this_present_service_name = true && this.isSetService_name();
      boolean that_present_service_name = true && that.isSetService_name();
      if (this_present_service_name || that_present_service_name) {
        if (!(this_present_service_name && that_present_service_name))
          return false;
        if (!this.service_name.equals(that.service_name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getSpanNames_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getSpanNames_args typedOther = (getSpanNames_args)other;

      lastComparison = Boolean.valueOf(isSetService_name()).compareTo(typedOther.isSetService_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetService_name()) {
        lastComparison = TBaseHelper.compareTo(this.service_name, typedOther.service_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // SERVICE_NAME
            if (field.type == TType.STRING) {
              this.service_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.service_name != null) {
        oprot.writeFieldBegin(SERVICE_NAME_FIELD_DESC);
        oprot.writeString(this.service_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getSpanNames_args(");
      boolean first = true;

      sb.append("service_name:");
      if (this.service_name == null) {
        sb.append("null");
      } else {
        sb.append(this.service_name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getSpanNames_result implements TBase<getSpanNames_result, getSpanNames_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getSpanNames_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.SET, (short)0);
    private static final TField QE_FIELD_DESC = new TField("qe", TType.STRUCT, (short)1);

    public Set<String> success;
    public QueryException qe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      QE((short)1, "qe");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // QE
            return QE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new SetMetaData(TType.SET, 
              new FieldValueMetaData(TType.STRING))));
      tmpMap.put(_Fields.QE, new FieldMetaData("qe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getSpanNames_result.class, metaDataMap);
    }

    public getSpanNames_result() {
    }

    public getSpanNames_result(
      Set<String> success,
      QueryException qe)
    {
      this();
      this.success = success;
      this.qe = qe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getSpanNames_result(getSpanNames_result other) {
      if (other.isSetSuccess()) {
        Set<String> __this__success = new HashSet<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetQe()) {
        this.qe = new QueryException(other.qe);
      }
    }

    public getSpanNames_result deepCopy() {
      return new getSpanNames_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.qe = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new HashSet<String>();
      }
      this.success.add(elem);
    }

    public Set<String> getSuccess() {
      return this.success;
    }

    public getSpanNames_result setSuccess(Set<String> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public QueryException getQe() {
      return this.qe;
    }

    public getSpanNames_result setQe(QueryException qe) {
      this.qe = qe;
      return this;
    }

    public void unsetQe() {
      this.qe = null;
    }

    /** Returns true if field qe is set (has been asigned a value) and false otherwise */
    public boolean isSetQe() {
      return this.qe != null;
    }

    public void setQeIsSet(boolean value) {
      if (!value) {
        this.qe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Set<String>)value);
        }
        break;

      case QE:
        if (value == null) {
          unsetQe();
        } else {
          setQe((QueryException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case QE:
        return getQe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case QE:
        return isSetQe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getSpanNames_result)
        return this.equals((getSpanNames_result)that);
      return false;
    }

    public boolean equals(getSpanNames_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_qe = true && this.isSetQe();
      boolean that_present_qe = true && that.isSetQe();
      if (this_present_qe || that_present_qe) {
        if (!(this_present_qe && that_present_qe))
          return false;
        if (!this.qe.equals(that.qe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getSpanNames_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getSpanNames_result typedOther = (getSpanNames_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetQe()).compareTo(typedOther.isSetQe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQe()) {
        lastComparison = TBaseHelper.compareTo(this.qe, typedOther.qe);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.SET) {
              {
                TSet _set110 = iprot.readSetBegin();
                this.success = new HashSet<String>(2*_set110.size);
                for (int _i111 = 0; _i111 < _set110.size; ++_i111)
                {
                  String _elem112;
                  _elem112 = iprot.readString();
                  this.success.add(_elem112);
                }
                iprot.readSetEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // QE
            if (field.type == TType.STRUCT) {
              this.qe = new QueryException();
              this.qe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeSetBegin(new TSet(TType.STRING, this.success.size()));
          for (String _iter113 : this.success)
          {
            oprot.writeString(_iter113);
          }
          oprot.writeSetEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetQe()) {
        oprot.writeFieldBegin(QE_FIELD_DESC);
        this.qe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getSpanNames_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("qe:");
      if (this.qe == null) {
        sb.append("null");
      } else {
        sb.append(this.qe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setTraceTimeToLive_args implements TBase<setTraceTimeToLive_args, setTraceTimeToLive_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setTraceTimeToLive_args");

    private static final TField TRACE_ID_FIELD_DESC = new TField("trace_id", TType.I64, (short)1);
    private static final TField TTL_SECONDS_FIELD_DESC = new TField("ttl_seconds", TType.I32, (short)2);

    public long trace_id;
    public int ttl_seconds;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TRACE_ID((short)1, "trace_id"),
      TTL_SECONDS((short)2, "ttl_seconds");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TRACE_ID
            return TRACE_ID;
          case 2: // TTL_SECONDS
            return TTL_SECONDS;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TRACE_ID_ISSET_ID = 0;
    private static final int __TTL_SECONDS_ISSET_ID = 1;
    private BitSet __isset_bit_vector = new BitSet(2);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TRACE_ID, new FieldMetaData("trace_id", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      tmpMap.put(_Fields.TTL_SECONDS, new FieldMetaData("ttl_seconds", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(setTraceTimeToLive_args.class, metaDataMap);
    }

    public setTraceTimeToLive_args() {
    }

    public setTraceTimeToLive_args(
      long trace_id,
      int ttl_seconds)
    {
      this();
      this.trace_id = trace_id;
      setTrace_idIsSet(true);
      this.ttl_seconds = ttl_seconds;
      setTtl_secondsIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setTraceTimeToLive_args(setTraceTimeToLive_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.trace_id = other.trace_id;
      this.ttl_seconds = other.ttl_seconds;
    }

    public setTraceTimeToLive_args deepCopy() {
      return new setTraceTimeToLive_args(this);
    }

    @Override
    public void clear() {
      setTrace_idIsSet(false);
      this.trace_id = 0;
      setTtl_secondsIsSet(false);
      this.ttl_seconds = 0;
    }

    public long getTrace_id() {
      return this.trace_id;
    }

    public setTraceTimeToLive_args setTrace_id(long trace_id) {
      this.trace_id = trace_id;
      setTrace_idIsSet(true);
      return this;
    }

    public void unsetTrace_id() {
      __isset_bit_vector.clear(__TRACE_ID_ISSET_ID);
    }

    /** Returns true if field trace_id is set (has been asigned a value) and false otherwise */
    public boolean isSetTrace_id() {
      return __isset_bit_vector.get(__TRACE_ID_ISSET_ID);
    }

    public void setTrace_idIsSet(boolean value) {
      __isset_bit_vector.set(__TRACE_ID_ISSET_ID, value);
    }

    public int getTtl_seconds() {
      return this.ttl_seconds;
    }

    public setTraceTimeToLive_args setTtl_seconds(int ttl_seconds) {
      this.ttl_seconds = ttl_seconds;
      setTtl_secondsIsSet(true);
      return this;
    }

    public void unsetTtl_seconds() {
      __isset_bit_vector.clear(__TTL_SECONDS_ISSET_ID);
    }

    /** Returns true if field ttl_seconds is set (has been asigned a value) and false otherwise */
    public boolean isSetTtl_seconds() {
      return __isset_bit_vector.get(__TTL_SECONDS_ISSET_ID);
    }

    public void setTtl_secondsIsSet(boolean value) {
      __isset_bit_vector.set(__TTL_SECONDS_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TRACE_ID:
        if (value == null) {
          unsetTrace_id();
        } else {
          setTrace_id((Long)value);
        }
        break;

      case TTL_SECONDS:
        if (value == null) {
          unsetTtl_seconds();
        } else {
          setTtl_seconds((Integer)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TRACE_ID:
        return new Long(getTrace_id());

      case TTL_SECONDS:
        return new Integer(getTtl_seconds());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TRACE_ID:
        return isSetTrace_id();
      case TTL_SECONDS:
        return isSetTtl_seconds();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setTraceTimeToLive_args)
        return this.equals((setTraceTimeToLive_args)that);
      return false;
    }

    public boolean equals(setTraceTimeToLive_args that) {
      if (that == null)
        return false;

      boolean this_present_trace_id = true;
      boolean that_present_trace_id = true;
      if (this_present_trace_id || that_present_trace_id) {
        if (!(this_present_trace_id && that_present_trace_id))
          return false;
        if (this.trace_id != that.trace_id)
          return false;
      }

      boolean this_present_ttl_seconds = true;
      boolean that_present_ttl_seconds = true;
      if (this_present_ttl_seconds || that_present_ttl_seconds) {
        if (!(this_present_ttl_seconds && that_present_ttl_seconds))
          return false;
        if (this.ttl_seconds != that.ttl_seconds)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(setTraceTimeToLive_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      setTraceTimeToLive_args typedOther = (setTraceTimeToLive_args)other;

      lastComparison = Boolean.valueOf(isSetTrace_id()).compareTo(typedOther.isSetTrace_id());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTrace_id()) {
        lastComparison = TBaseHelper.compareTo(this.trace_id, typedOther.trace_id);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetTtl_seconds()).compareTo(typedOther.isSetTtl_seconds());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTtl_seconds()) {
        lastComparison = TBaseHelper.compareTo(this.ttl_seconds, typedOther.ttl_seconds);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // TRACE_ID
            if (field.type == TType.I64) {
              this.trace_id = iprot.readI64();
              setTrace_idIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 2: // TTL_SECONDS
            if (field.type == TType.I32) {
              this.ttl_seconds = iprot.readI32();
              setTtl_secondsIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(TRACE_ID_FIELD_DESC);
      oprot.writeI64(this.trace_id);
      oprot.writeFieldEnd();
      oprot.writeFieldBegin(TTL_SECONDS_FIELD_DESC);
      oprot.writeI32(this.ttl_seconds);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("setTraceTimeToLive_args(");
      boolean first = true;

      sb.append("trace_id:");
      sb.append(this.trace_id);
      first = false;
      if (!first) sb.append(", ");
      sb.append("ttl_seconds:");
      sb.append(this.ttl_seconds);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class setTraceTimeToLive_result implements TBase<setTraceTimeToLive_result, setTraceTimeToLive_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("setTraceTimeToLive_result");

    private static final TField QE_FIELD_DESC = new TField("qe", TType.STRUCT, (short)1);

    public QueryException qe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      QE((short)1, "qe");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // QE
            return QE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.QE, new FieldMetaData("qe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(setTraceTimeToLive_result.class, metaDataMap);
    }

    public setTraceTimeToLive_result() {
    }

    public setTraceTimeToLive_result(
      QueryException qe)
    {
      this();
      this.qe = qe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public setTraceTimeToLive_result(setTraceTimeToLive_result other) {
      if (other.isSetQe()) {
        this.qe = new QueryException(other.qe);
      }
    }

    public setTraceTimeToLive_result deepCopy() {
      return new setTraceTimeToLive_result(this);
    }

    @Override
    public void clear() {
      this.qe = null;
    }

    public QueryException getQe() {
      return this.qe;
    }

    public setTraceTimeToLive_result setQe(QueryException qe) {
      this.qe = qe;
      return this;
    }

    public void unsetQe() {
      this.qe = null;
    }

    /** Returns true if field qe is set (has been asigned a value) and false otherwise */
    public boolean isSetQe() {
      return this.qe != null;
    }

    public void setQeIsSet(boolean value) {
      if (!value) {
        this.qe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case QE:
        if (value == null) {
          unsetQe();
        } else {
          setQe((QueryException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case QE:
        return getQe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case QE:
        return isSetQe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof setTraceTimeToLive_result)
        return this.equals((setTraceTimeToLive_result)that);
      return false;
    }

    public boolean equals(setTraceTimeToLive_result that) {
      if (that == null)
        return false;

      boolean this_present_qe = true && this.isSetQe();
      boolean that_present_qe = true && that.isSetQe();
      if (this_present_qe || that_present_qe) {
        if (!(this_present_qe && that_present_qe))
          return false;
        if (!this.qe.equals(that.qe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(setTraceTimeToLive_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      setTraceTimeToLive_result typedOther = (setTraceTimeToLive_result)other;

      lastComparison = Boolean.valueOf(isSetQe()).compareTo(typedOther.isSetQe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQe()) {
        lastComparison = TBaseHelper.compareTo(this.qe, typedOther.qe);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // QE
            if (field.type == TType.STRUCT) {
              this.qe = new QueryException();
              this.qe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetQe()) {
        oprot.writeFieldBegin(QE_FIELD_DESC);
        this.qe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("setTraceTimeToLive_result(");
      boolean first = true;

      sb.append("qe:");
      if (this.qe == null) {
        sb.append("null");
      } else {
        sb.append(this.qe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTraceTimeToLive_args implements TBase<getTraceTimeToLive_args, getTraceTimeToLive_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTraceTimeToLive_args");

    private static final TField TRACE_ID_FIELD_DESC = new TField("trace_id", TType.I64, (short)1);

    public long trace_id;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      TRACE_ID((short)1, "trace_id");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // TRACE_ID
            return TRACE_ID;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __TRACE_ID_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.TRACE_ID, new FieldMetaData("trace_id", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I64)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTraceTimeToLive_args.class, metaDataMap);
    }

    public getTraceTimeToLive_args() {
    }

    public getTraceTimeToLive_args(
      long trace_id)
    {
      this();
      this.trace_id = trace_id;
      setTrace_idIsSet(true);
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTraceTimeToLive_args(getTraceTimeToLive_args other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.trace_id = other.trace_id;
    }

    public getTraceTimeToLive_args deepCopy() {
      return new getTraceTimeToLive_args(this);
    }

    @Override
    public void clear() {
      setTrace_idIsSet(false);
      this.trace_id = 0;
    }

    public long getTrace_id() {
      return this.trace_id;
    }

    public getTraceTimeToLive_args setTrace_id(long trace_id) {
      this.trace_id = trace_id;
      setTrace_idIsSet(true);
      return this;
    }

    public void unsetTrace_id() {
      __isset_bit_vector.clear(__TRACE_ID_ISSET_ID);
    }

    /** Returns true if field trace_id is set (has been asigned a value) and false otherwise */
    public boolean isSetTrace_id() {
      return __isset_bit_vector.get(__TRACE_ID_ISSET_ID);
    }

    public void setTrace_idIsSet(boolean value) {
      __isset_bit_vector.set(__TRACE_ID_ISSET_ID, value);
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case TRACE_ID:
        if (value == null) {
          unsetTrace_id();
        } else {
          setTrace_id((Long)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case TRACE_ID:
        return new Long(getTrace_id());

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case TRACE_ID:
        return isSetTrace_id();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTraceTimeToLive_args)
        return this.equals((getTraceTimeToLive_args)that);
      return false;
    }

    public boolean equals(getTraceTimeToLive_args that) {
      if (that == null)
        return false;

      boolean this_present_trace_id = true;
      boolean that_present_trace_id = true;
      if (this_present_trace_id || that_present_trace_id) {
        if (!(this_present_trace_id && that_present_trace_id))
          return false;
        if (this.trace_id != that.trace_id)
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTraceTimeToLive_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTraceTimeToLive_args typedOther = (getTraceTimeToLive_args)other;

      lastComparison = Boolean.valueOf(isSetTrace_id()).compareTo(typedOther.isSetTrace_id());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetTrace_id()) {
        lastComparison = TBaseHelper.compareTo(this.trace_id, typedOther.trace_id);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // TRACE_ID
            if (field.type == TType.I64) {
              this.trace_id = iprot.readI64();
              setTrace_idIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldBegin(TRACE_ID_FIELD_DESC);
      oprot.writeI64(this.trace_id);
      oprot.writeFieldEnd();
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTraceTimeToLive_args(");
      boolean first = true;

      sb.append("trace_id:");
      sb.append(this.trace_id);
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTraceTimeToLive_result implements TBase<getTraceTimeToLive_result, getTraceTimeToLive_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTraceTimeToLive_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
    private static final TField QE_FIELD_DESC = new TField("qe", TType.STRUCT, (short)1);

    public int success;
    public QueryException qe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      QE((short)1, "qe");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // QE
            return QE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      tmpMap.put(_Fields.QE, new FieldMetaData("qe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTraceTimeToLive_result.class, metaDataMap);
    }

    public getTraceTimeToLive_result() {
    }

    public getTraceTimeToLive_result(
      int success,
      QueryException qe)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.qe = qe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTraceTimeToLive_result(getTraceTimeToLive_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetQe()) {
        this.qe = new QueryException(other.qe);
      }
    }

    public getTraceTimeToLive_result deepCopy() {
      return new getTraceTimeToLive_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.qe = null;
    }

    public int getSuccess() {
      return this.success;
    }

    public getTraceTimeToLive_result setSuccess(int success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public QueryException getQe() {
      return this.qe;
    }

    public getTraceTimeToLive_result setQe(QueryException qe) {
      this.qe = qe;
      return this;
    }

    public void unsetQe() {
      this.qe = null;
    }

    /** Returns true if field qe is set (has been asigned a value) and false otherwise */
    public boolean isSetQe() {
      return this.qe != null;
    }

    public void setQeIsSet(boolean value) {
      if (!value) {
        this.qe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case QE:
        if (value == null) {
          unsetQe();
        } else {
          setQe((QueryException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Integer(getSuccess());

      case QE:
        return getQe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case QE:
        return isSetQe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTraceTimeToLive_result)
        return this.equals((getTraceTimeToLive_result)that);
      return false;
    }

    public boolean equals(getTraceTimeToLive_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_qe = true && this.isSetQe();
      boolean that_present_qe = true && that.isSetQe();
      if (this_present_qe || that_present_qe) {
        if (!(this_present_qe && that_present_qe))
          return false;
        if (!this.qe.equals(that.qe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTraceTimeToLive_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTraceTimeToLive_result typedOther = (getTraceTimeToLive_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetQe()).compareTo(typedOther.isSetQe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQe()) {
        lastComparison = TBaseHelper.compareTo(this.qe, typedOther.qe);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.I32) {
              this.success = iprot.readI32();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // QE
            if (field.type == TType.STRUCT) {
              this.qe = new QueryException();
              this.qe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI32(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetQe()) {
        oprot.writeFieldBegin(QE_FIELD_DESC);
        this.qe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTraceTimeToLive_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("qe:");
      if (this.qe == null) {
        sb.append("null");
      } else {
        sb.append(this.qe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getDataTimeToLive_args implements TBase<getDataTimeToLive_args, getDataTimeToLive_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getDataTimeToLive_args");



    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
;

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }
    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getDataTimeToLive_args.class, metaDataMap);
    }

    public getDataTimeToLive_args() {
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getDataTimeToLive_args(getDataTimeToLive_args other) {
    }

    public getDataTimeToLive_args deepCopy() {
      return new getDataTimeToLive_args(this);
    }

    @Override
    public void clear() {
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getDataTimeToLive_args)
        return this.equals((getDataTimeToLive_args)that);
      return false;
    }

    public boolean equals(getDataTimeToLive_args that) {
      if (that == null)
        return false;

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getDataTimeToLive_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getDataTimeToLive_args typedOther = (getDataTimeToLive_args)other;

      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getDataTimeToLive_args(");
      boolean first = true;

      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getDataTimeToLive_result implements TBase<getDataTimeToLive_result, getDataTimeToLive_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getDataTimeToLive_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.I32, (short)0);
    private static final TField QE_FIELD_DESC = new TField("qe", TType.STRUCT, (short)1);

    public int success;
    public QueryException qe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      QE((short)1, "qe");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // QE
            return QE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments
    private static final int __SUCCESS_ISSET_ID = 0;
    private BitSet __isset_bit_vector = new BitSet(1);

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.I32)));
      tmpMap.put(_Fields.QE, new FieldMetaData("qe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getDataTimeToLive_result.class, metaDataMap);
    }

    public getDataTimeToLive_result() {
    }

    public getDataTimeToLive_result(
      int success,
      QueryException qe)
    {
      this();
      this.success = success;
      setSuccessIsSet(true);
      this.qe = qe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getDataTimeToLive_result(getDataTimeToLive_result other) {
      __isset_bit_vector.clear();
      __isset_bit_vector.or(other.__isset_bit_vector);
      this.success = other.success;
      if (other.isSetQe()) {
        this.qe = new QueryException(other.qe);
      }
    }

    public getDataTimeToLive_result deepCopy() {
      return new getDataTimeToLive_result(this);
    }

    @Override
    public void clear() {
      setSuccessIsSet(false);
      this.success = 0;
      this.qe = null;
    }

    public int getSuccess() {
      return this.success;
    }

    public getDataTimeToLive_result setSuccess(int success) {
      this.success = success;
      setSuccessIsSet(true);
      return this;
    }

    public void unsetSuccess() {
      __isset_bit_vector.clear(__SUCCESS_ISSET_ID);
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return __isset_bit_vector.get(__SUCCESS_ISSET_ID);
    }

    public void setSuccessIsSet(boolean value) {
      __isset_bit_vector.set(__SUCCESS_ISSET_ID, value);
    }

    public QueryException getQe() {
      return this.qe;
    }

    public getDataTimeToLive_result setQe(QueryException qe) {
      this.qe = qe;
      return this;
    }

    public void unsetQe() {
      this.qe = null;
    }

    /** Returns true if field qe is set (has been asigned a value) and false otherwise */
    public boolean isSetQe() {
      return this.qe != null;
    }

    public void setQeIsSet(boolean value) {
      if (!value) {
        this.qe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((Integer)value);
        }
        break;

      case QE:
        if (value == null) {
          unsetQe();
        } else {
          setQe((QueryException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return new Integer(getSuccess());

      case QE:
        return getQe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case QE:
        return isSetQe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getDataTimeToLive_result)
        return this.equals((getDataTimeToLive_result)that);
      return false;
    }

    public boolean equals(getDataTimeToLive_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true;
      boolean that_present_success = true;
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (this.success != that.success)
          return false;
      }

      boolean this_present_qe = true && this.isSetQe();
      boolean that_present_qe = true && that.isSetQe();
      if (this_present_qe || that_present_qe) {
        if (!(this_present_qe && that_present_qe))
          return false;
        if (!this.qe.equals(that.qe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getDataTimeToLive_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getDataTimeToLive_result typedOther = (getDataTimeToLive_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetQe()).compareTo(typedOther.isSetQe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQe()) {
        lastComparison = TBaseHelper.compareTo(this.qe, typedOther.qe);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.I32) {
              this.success = iprot.readI32();
              setSuccessIsSet(true);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // QE
            if (field.type == TType.STRUCT) {
              this.qe = new QueryException();
              this.qe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        oprot.writeI32(this.success);
        oprot.writeFieldEnd();
      } else if (this.isSetQe()) {
        oprot.writeFieldBegin(QE_FIELD_DESC);
        this.qe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getDataTimeToLive_result(");
      boolean first = true;

      sb.append("success:");
      sb.append(this.success);
      first = false;
      if (!first) sb.append(", ");
      sb.append("qe:");
      if (this.qe == null) {
        sb.append("null");
      } else {
        sb.append(this.qe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getDependencies_args implements TBase<getDependencies_args, getDependencies_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getDependencies_args");

    private static final TField SERVICE_NAME_FIELD_DESC = new TField("service_name", TType.STRING, (short)1);

    public String service_name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SERVICE_NAME((short)1, "service_name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SERVICE_NAME
            return SERVICE_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SERVICE_NAME, new FieldMetaData("service_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getDependencies_args.class, metaDataMap);
    }

    public getDependencies_args() {
    }

    public getDependencies_args(
      String service_name)
    {
      this();
      this.service_name = service_name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getDependencies_args(getDependencies_args other) {
      if (other.isSetService_name()) {
        this.service_name = other.service_name;
      }
    }

    public getDependencies_args deepCopy() {
      return new getDependencies_args(this);
    }

    @Override
    public void clear() {
      this.service_name = null;
    }

    public String getService_name() {
      return this.service_name;
    }

    public getDependencies_args setService_name(String service_name) {
      this.service_name = service_name;
      return this;
    }

    public void unsetService_name() {
      this.service_name = null;
    }

    /** Returns true if field service_name is set (has been asigned a value) and false otherwise */
    public boolean isSetService_name() {
      return this.service_name != null;
    }

    public void setService_nameIsSet(boolean value) {
      if (!value) {
        this.service_name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SERVICE_NAME:
        if (value == null) {
          unsetService_name();
        } else {
          setService_name((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SERVICE_NAME:
        return getService_name();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SERVICE_NAME:
        return isSetService_name();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getDependencies_args)
        return this.equals((getDependencies_args)that);
      return false;
    }

    public boolean equals(getDependencies_args that) {
      if (that == null)
        return false;

      boolean this_present_service_name = true && this.isSetService_name();
      boolean that_present_service_name = true && that.isSetService_name();
      if (this_present_service_name || that_present_service_name) {
        if (!(this_present_service_name && that_present_service_name))
          return false;
        if (!this.service_name.equals(that.service_name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getDependencies_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getDependencies_args typedOther = (getDependencies_args)other;

      lastComparison = Boolean.valueOf(isSetService_name()).compareTo(typedOther.isSetService_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetService_name()) {
        lastComparison = TBaseHelper.compareTo(this.service_name, typedOther.service_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // SERVICE_NAME
            if (field.type == TType.STRING) {
              this.service_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.service_name != null) {
        oprot.writeFieldBegin(SERVICE_NAME_FIELD_DESC);
        oprot.writeString(this.service_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getDependencies_args(");
      boolean first = true;

      sb.append("service_name:");
      if (this.service_name == null) {
        sb.append("null");
      } else {
        sb.append(this.service_name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getDependencies_result implements TBase<getDependencies_result, getDependencies_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getDependencies_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField QE_FIELD_DESC = new TField("qe", TType.STRUCT, (short)1);

    public List<String> success;
    public QueryException qe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      QE((short)1, "qe");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // QE
            return QE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      tmpMap.put(_Fields.QE, new FieldMetaData("qe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getDependencies_result.class, metaDataMap);
    }

    public getDependencies_result() {
    }

    public getDependencies_result(
      List<String> success,
      QueryException qe)
    {
      this();
      this.success = success;
      this.qe = qe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getDependencies_result(getDependencies_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetQe()) {
        this.qe = new QueryException(other.qe);
      }
    }

    public getDependencies_result deepCopy() {
      return new getDependencies_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.qe = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public getDependencies_result setSuccess(List<String> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public QueryException getQe() {
      return this.qe;
    }

    public getDependencies_result setQe(QueryException qe) {
      this.qe = qe;
      return this;
    }

    public void unsetQe() {
      this.qe = null;
    }

    /** Returns true if field qe is set (has been asigned a value) and false otherwise */
    public boolean isSetQe() {
      return this.qe != null;
    }

    public void setQeIsSet(boolean value) {
      if (!value) {
        this.qe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      case QE:
        if (value == null) {
          unsetQe();
        } else {
          setQe((QueryException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case QE:
        return getQe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case QE:
        return isSetQe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getDependencies_result)
        return this.equals((getDependencies_result)that);
      return false;
    }

    public boolean equals(getDependencies_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_qe = true && this.isSetQe();
      boolean that_present_qe = true && that.isSetQe();
      if (this_present_qe || that_present_qe) {
        if (!(this_present_qe && that_present_qe))
          return false;
        if (!this.qe.equals(that.qe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getDependencies_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getDependencies_result typedOther = (getDependencies_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetQe()).compareTo(typedOther.isSetQe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQe()) {
        lastComparison = TBaseHelper.compareTo(this.qe, typedOther.qe);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list114 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list114.size);
                for (int _i115 = 0; _i115 < _list114.size; ++_i115)
                {
                  String _elem116;
                  _elem116 = iprot.readString();
                  this.success.add(_elem116);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // QE
            if (field.type == TType.STRUCT) {
              this.qe = new QueryException();
              this.qe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter117 : this.success)
          {
            oprot.writeString(_iter117);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetQe()) {
        oprot.writeFieldBegin(QE_FIELD_DESC);
        this.qe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getDependencies_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("qe:");
      if (this.qe == null) {
        sb.append("null");
      } else {
        sb.append(this.qe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTopAnnotations_args implements TBase<getTopAnnotations_args, getTopAnnotations_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTopAnnotations_args");

    private static final TField SERVICE_NAME_FIELD_DESC = new TField("service_name", TType.STRING, (short)1);

    public String service_name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SERVICE_NAME((short)1, "service_name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SERVICE_NAME
            return SERVICE_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SERVICE_NAME, new FieldMetaData("service_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTopAnnotations_args.class, metaDataMap);
    }

    public getTopAnnotations_args() {
    }

    public getTopAnnotations_args(
      String service_name)
    {
      this();
      this.service_name = service_name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTopAnnotations_args(getTopAnnotations_args other) {
      if (other.isSetService_name()) {
        this.service_name = other.service_name;
      }
    }

    public getTopAnnotations_args deepCopy() {
      return new getTopAnnotations_args(this);
    }

    @Override
    public void clear() {
      this.service_name = null;
    }

    public String getService_name() {
      return this.service_name;
    }

    public getTopAnnotations_args setService_name(String service_name) {
      this.service_name = service_name;
      return this;
    }

    public void unsetService_name() {
      this.service_name = null;
    }

    /** Returns true if field service_name is set (has been asigned a value) and false otherwise */
    public boolean isSetService_name() {
      return this.service_name != null;
    }

    public void setService_nameIsSet(boolean value) {
      if (!value) {
        this.service_name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SERVICE_NAME:
        if (value == null) {
          unsetService_name();
        } else {
          setService_name((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SERVICE_NAME:
        return getService_name();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SERVICE_NAME:
        return isSetService_name();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTopAnnotations_args)
        return this.equals((getTopAnnotations_args)that);
      return false;
    }

    public boolean equals(getTopAnnotations_args that) {
      if (that == null)
        return false;

      boolean this_present_service_name = true && this.isSetService_name();
      boolean that_present_service_name = true && that.isSetService_name();
      if (this_present_service_name || that_present_service_name) {
        if (!(this_present_service_name && that_present_service_name))
          return false;
        if (!this.service_name.equals(that.service_name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTopAnnotations_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTopAnnotations_args typedOther = (getTopAnnotations_args)other;

      lastComparison = Boolean.valueOf(isSetService_name()).compareTo(typedOther.isSetService_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetService_name()) {
        lastComparison = TBaseHelper.compareTo(this.service_name, typedOther.service_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // SERVICE_NAME
            if (field.type == TType.STRING) {
              this.service_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.service_name != null) {
        oprot.writeFieldBegin(SERVICE_NAME_FIELD_DESC);
        oprot.writeString(this.service_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTopAnnotations_args(");
      boolean first = true;

      sb.append("service_name:");
      if (this.service_name == null) {
        sb.append("null");
      } else {
        sb.append(this.service_name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTopAnnotations_result implements TBase<getTopAnnotations_result, getTopAnnotations_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTopAnnotations_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField QE_FIELD_DESC = new TField("qe", TType.STRUCT, (short)1);

    public List<String> success;
    public QueryException qe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      QE((short)1, "qe");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // QE
            return QE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      tmpMap.put(_Fields.QE, new FieldMetaData("qe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTopAnnotations_result.class, metaDataMap);
    }

    public getTopAnnotations_result() {
    }

    public getTopAnnotations_result(
      List<String> success,
      QueryException qe)
    {
      this();
      this.success = success;
      this.qe = qe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTopAnnotations_result(getTopAnnotations_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetQe()) {
        this.qe = new QueryException(other.qe);
      }
    }

    public getTopAnnotations_result deepCopy() {
      return new getTopAnnotations_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.qe = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public getTopAnnotations_result setSuccess(List<String> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public QueryException getQe() {
      return this.qe;
    }

    public getTopAnnotations_result setQe(QueryException qe) {
      this.qe = qe;
      return this;
    }

    public void unsetQe() {
      this.qe = null;
    }

    /** Returns true if field qe is set (has been asigned a value) and false otherwise */
    public boolean isSetQe() {
      return this.qe != null;
    }

    public void setQeIsSet(boolean value) {
      if (!value) {
        this.qe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      case QE:
        if (value == null) {
          unsetQe();
        } else {
          setQe((QueryException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case QE:
        return getQe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case QE:
        return isSetQe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTopAnnotations_result)
        return this.equals((getTopAnnotations_result)that);
      return false;
    }

    public boolean equals(getTopAnnotations_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_qe = true && this.isSetQe();
      boolean that_present_qe = true && that.isSetQe();
      if (this_present_qe || that_present_qe) {
        if (!(this_present_qe && that_present_qe))
          return false;
        if (!this.qe.equals(that.qe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTopAnnotations_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTopAnnotations_result typedOther = (getTopAnnotations_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetQe()).compareTo(typedOther.isSetQe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQe()) {
        lastComparison = TBaseHelper.compareTo(this.qe, typedOther.qe);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list118 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list118.size);
                for (int _i119 = 0; _i119 < _list118.size; ++_i119)
                {
                  String _elem120;
                  _elem120 = iprot.readString();
                  this.success.add(_elem120);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // QE
            if (field.type == TType.STRUCT) {
              this.qe = new QueryException();
              this.qe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter121 : this.success)
          {
            oprot.writeString(_iter121);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetQe()) {
        oprot.writeFieldBegin(QE_FIELD_DESC);
        this.qe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTopAnnotations_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("qe:");
      if (this.qe == null) {
        sb.append("null");
      } else {
        sb.append(this.qe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTopKeyValueAnnotations_args implements TBase<getTopKeyValueAnnotations_args, getTopKeyValueAnnotations_args._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTopKeyValueAnnotations_args");

    private static final TField SERVICE_NAME_FIELD_DESC = new TField("service_name", TType.STRING, (short)1);

    public String service_name;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SERVICE_NAME((short)1, "service_name");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 1: // SERVICE_NAME
            return SERVICE_NAME;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SERVICE_NAME, new FieldMetaData("service_name", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRING)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTopKeyValueAnnotations_args.class, metaDataMap);
    }

    public getTopKeyValueAnnotations_args() {
    }

    public getTopKeyValueAnnotations_args(
      String service_name)
    {
      this();
      this.service_name = service_name;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTopKeyValueAnnotations_args(getTopKeyValueAnnotations_args other) {
      if (other.isSetService_name()) {
        this.service_name = other.service_name;
      }
    }

    public getTopKeyValueAnnotations_args deepCopy() {
      return new getTopKeyValueAnnotations_args(this);
    }

    @Override
    public void clear() {
      this.service_name = null;
    }

    public String getService_name() {
      return this.service_name;
    }

    public getTopKeyValueAnnotations_args setService_name(String service_name) {
      this.service_name = service_name;
      return this;
    }

    public void unsetService_name() {
      this.service_name = null;
    }

    /** Returns true if field service_name is set (has been asigned a value) and false otherwise */
    public boolean isSetService_name() {
      return this.service_name != null;
    }

    public void setService_nameIsSet(boolean value) {
      if (!value) {
        this.service_name = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SERVICE_NAME:
        if (value == null) {
          unsetService_name();
        } else {
          setService_name((String)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SERVICE_NAME:
        return getService_name();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SERVICE_NAME:
        return isSetService_name();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTopKeyValueAnnotations_args)
        return this.equals((getTopKeyValueAnnotations_args)that);
      return false;
    }

    public boolean equals(getTopKeyValueAnnotations_args that) {
      if (that == null)
        return false;

      boolean this_present_service_name = true && this.isSetService_name();
      boolean that_present_service_name = true && that.isSetService_name();
      if (this_present_service_name || that_present_service_name) {
        if (!(this_present_service_name && that_present_service_name))
          return false;
        if (!this.service_name.equals(that.service_name))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTopKeyValueAnnotations_args other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTopKeyValueAnnotations_args typedOther = (getTopKeyValueAnnotations_args)other;

      lastComparison = Boolean.valueOf(isSetService_name()).compareTo(typedOther.isSetService_name());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetService_name()) {
        lastComparison = TBaseHelper.compareTo(this.service_name, typedOther.service_name);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 1: // SERVICE_NAME
            if (field.type == TType.STRING) {
              this.service_name = iprot.readString();
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      validate();

      oprot.writeStructBegin(STRUCT_DESC);
      if (this.service_name != null) {
        oprot.writeFieldBegin(SERVICE_NAME_FIELD_DESC);
        oprot.writeString(this.service_name);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTopKeyValueAnnotations_args(");
      boolean first = true;

      sb.append("service_name:");
      if (this.service_name == null) {
        sb.append("null");
      } else {
        sb.append(this.service_name);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

  public static class getTopKeyValueAnnotations_result implements TBase<getTopKeyValueAnnotations_result, getTopKeyValueAnnotations_result._Fields>, java.io.Serializable, Cloneable   {
    private static final TStruct STRUCT_DESC = new TStruct("getTopKeyValueAnnotations_result");

    private static final TField SUCCESS_FIELD_DESC = new TField("success", TType.LIST, (short)0);
    private static final TField QE_FIELD_DESC = new TField("qe", TType.STRUCT, (short)1);

    public List<String> success;
    public QueryException qe;

    /** The set of fields this struct contains, along with convenience methods for finding and manipulating them. */
    public enum _Fields implements TFieldIdEnum {
      SUCCESS((short)0, "success"),
      QE((short)1, "qe");

      private static final Map<String, _Fields> byName = new HashMap<String, _Fields>();

      static {
        for (_Fields field : EnumSet.allOf(_Fields.class)) {
          byName.put(field.getFieldName(), field);
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, or null if its not found.
       */
      public static _Fields findByThriftId(int fieldId) {
        switch(fieldId) {
          case 0: // SUCCESS
            return SUCCESS;
          case 1: // QE
            return QE;
          default:
            return null;
        }
      }

      /**
       * Find the _Fields constant that matches fieldId, throwing an exception
       * if it is not found.
       */
      public static _Fields findByThriftIdOrThrow(int fieldId) {
        _Fields fields = findByThriftId(fieldId);
        if (fields == null) throw new IllegalArgumentException("Field " + fieldId + " doesn't exist!");
        return fields;
      }

      /**
       * Find the _Fields constant that matches name, or null if its not found.
       */
      public static _Fields findByName(String name) {
        return byName.get(name);
      }

      private final short _thriftId;
      private final String _fieldName;

      _Fields(short thriftId, String fieldName) {
        _thriftId = thriftId;
        _fieldName = fieldName;
      }

      public short getThriftFieldId() {
        return _thriftId;
      }

      public String getFieldName() {
        return _fieldName;
      }
    }

    // isset id assignments

    public static final Map<_Fields, FieldMetaData> metaDataMap;
    static {
      Map<_Fields, FieldMetaData> tmpMap = new EnumMap<_Fields, FieldMetaData>(_Fields.class);
      tmpMap.put(_Fields.SUCCESS, new FieldMetaData("success", TFieldRequirementType.DEFAULT, 
          new ListMetaData(TType.LIST, 
              new FieldValueMetaData(TType.STRING))));
      tmpMap.put(_Fields.QE, new FieldMetaData("qe", TFieldRequirementType.DEFAULT, 
          new FieldValueMetaData(TType.STRUCT)));
      metaDataMap = Collections.unmodifiableMap(tmpMap);
      FieldMetaData.addStructMetaDataMap(getTopKeyValueAnnotations_result.class, metaDataMap);
    }

    public getTopKeyValueAnnotations_result() {
    }

    public getTopKeyValueAnnotations_result(
      List<String> success,
      QueryException qe)
    {
      this();
      this.success = success;
      this.qe = qe;
    }

    /**
     * Performs a deep copy on <i>other</i>.
     */
    public getTopKeyValueAnnotations_result(getTopKeyValueAnnotations_result other) {
      if (other.isSetSuccess()) {
        List<String> __this__success = new ArrayList<String>();
        for (String other_element : other.success) {
          __this__success.add(other_element);
        }
        this.success = __this__success;
      }
      if (other.isSetQe()) {
        this.qe = new QueryException(other.qe);
      }
    }

    public getTopKeyValueAnnotations_result deepCopy() {
      return new getTopKeyValueAnnotations_result(this);
    }

    @Override
    public void clear() {
      this.success = null;
      this.qe = null;
    }

    public int getSuccessSize() {
      return (this.success == null) ? 0 : this.success.size();
    }

    public java.util.Iterator<String> getSuccessIterator() {
      return (this.success == null) ? null : this.success.iterator();
    }

    public void addToSuccess(String elem) {
      if (this.success == null) {
        this.success = new ArrayList<String>();
      }
      this.success.add(elem);
    }

    public List<String> getSuccess() {
      return this.success;
    }

    public getTopKeyValueAnnotations_result setSuccess(List<String> success) {
      this.success = success;
      return this;
    }

    public void unsetSuccess() {
      this.success = null;
    }

    /** Returns true if field success is set (has been asigned a value) and false otherwise */
    public boolean isSetSuccess() {
      return this.success != null;
    }

    public void setSuccessIsSet(boolean value) {
      if (!value) {
        this.success = null;
      }
    }

    public QueryException getQe() {
      return this.qe;
    }

    public getTopKeyValueAnnotations_result setQe(QueryException qe) {
      this.qe = qe;
      return this;
    }

    public void unsetQe() {
      this.qe = null;
    }

    /** Returns true if field qe is set (has been asigned a value) and false otherwise */
    public boolean isSetQe() {
      return this.qe != null;
    }

    public void setQeIsSet(boolean value) {
      if (!value) {
        this.qe = null;
      }
    }

    public void setFieldValue(_Fields field, Object value) {
      switch (field) {
      case SUCCESS:
        if (value == null) {
          unsetSuccess();
        } else {
          setSuccess((List<String>)value);
        }
        break;

      case QE:
        if (value == null) {
          unsetQe();
        } else {
          setQe((QueryException)value);
        }
        break;

      }
    }

    public Object getFieldValue(_Fields field) {
      switch (field) {
      case SUCCESS:
        return getSuccess();

      case QE:
        return getQe();

      }
      throw new IllegalStateException();
    }

    /** Returns true if field corresponding to fieldID is set (has been asigned a value) and false otherwise */
    public boolean isSet(_Fields field) {
      if (field == null) {
        throw new IllegalArgumentException();
      }

      switch (field) {
      case SUCCESS:
        return isSetSuccess();
      case QE:
        return isSetQe();
      }
      throw new IllegalStateException();
    }

    @Override
    public boolean equals(Object that) {
      if (that == null)
        return false;
      if (that instanceof getTopKeyValueAnnotations_result)
        return this.equals((getTopKeyValueAnnotations_result)that);
      return false;
    }

    public boolean equals(getTopKeyValueAnnotations_result that) {
      if (that == null)
        return false;

      boolean this_present_success = true && this.isSetSuccess();
      boolean that_present_success = true && that.isSetSuccess();
      if (this_present_success || that_present_success) {
        if (!(this_present_success && that_present_success))
          return false;
        if (!this.success.equals(that.success))
          return false;
      }

      boolean this_present_qe = true && this.isSetQe();
      boolean that_present_qe = true && that.isSetQe();
      if (this_present_qe || that_present_qe) {
        if (!(this_present_qe && that_present_qe))
          return false;
        if (!this.qe.equals(that.qe))
          return false;
      }

      return true;
    }

    @Override
    public int hashCode() {
      return 0;
    }

    public int compareTo(getTopKeyValueAnnotations_result other) {
      if (!getClass().equals(other.getClass())) {
        return getClass().getName().compareTo(other.getClass().getName());
      }

      int lastComparison = 0;
      getTopKeyValueAnnotations_result typedOther = (getTopKeyValueAnnotations_result)other;

      lastComparison = Boolean.valueOf(isSetSuccess()).compareTo(typedOther.isSetSuccess());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetSuccess()) {
        lastComparison = TBaseHelper.compareTo(this.success, typedOther.success);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      lastComparison = Boolean.valueOf(isSetQe()).compareTo(typedOther.isSetQe());
      if (lastComparison != 0) {
        return lastComparison;
      }
      if (isSetQe()) {
        lastComparison = TBaseHelper.compareTo(this.qe, typedOther.qe);
        if (lastComparison != 0) {
          return lastComparison;
        }
      }
      return 0;
    }

    public _Fields fieldForId(int fieldId) {
      return _Fields.findByThriftId(fieldId);
    }

    public void read(TProtocol iprot) throws TException {
      TField field;
      iprot.readStructBegin();
      while (true)
      {
        field = iprot.readFieldBegin();
        if (field.type == TType.STOP) { 
          break;
        }
        switch (field.id) {
          case 0: // SUCCESS
            if (field.type == TType.LIST) {
              {
                TList _list122 = iprot.readListBegin();
                this.success = new ArrayList<String>(_list122.size);
                for (int _i123 = 0; _i123 < _list122.size; ++_i123)
                {
                  String _elem124;
                  _elem124 = iprot.readString();
                  this.success.add(_elem124);
                }
                iprot.readListEnd();
              }
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          case 1: // QE
            if (field.type == TType.STRUCT) {
              this.qe = new QueryException();
              this.qe.read(iprot);
            } else { 
              TProtocolUtil.skip(iprot, field.type);
            }
            break;
          default:
            TProtocolUtil.skip(iprot, field.type);
        }
        iprot.readFieldEnd();
      }
      iprot.readStructEnd();

      // check for required fields of primitive type, which can't be checked in the validate method
      validate();
    }

    public void write(TProtocol oprot) throws TException {
      oprot.writeStructBegin(STRUCT_DESC);

      if (this.isSetSuccess()) {
        oprot.writeFieldBegin(SUCCESS_FIELD_DESC);
        {
          oprot.writeListBegin(new TList(TType.STRING, this.success.size()));
          for (String _iter125 : this.success)
          {
            oprot.writeString(_iter125);
          }
          oprot.writeListEnd();
        }
        oprot.writeFieldEnd();
      } else if (this.isSetQe()) {
        oprot.writeFieldBegin(QE_FIELD_DESC);
        this.qe.write(oprot);
        oprot.writeFieldEnd();
      }
      oprot.writeFieldStop();
      oprot.writeStructEnd();
    }

    @Override
    public String toString() {
      StringBuilder sb = new StringBuilder("getTopKeyValueAnnotations_result(");
      boolean first = true;

      sb.append("success:");
      if (this.success == null) {
        sb.append("null");
      } else {
        sb.append(this.success);
      }
      first = false;
      if (!first) sb.append(", ");
      sb.append("qe:");
      if (this.qe == null) {
        sb.append("null");
      } else {
        sb.append(this.qe);
      }
      first = false;
      sb.append(")");
      return sb.toString();
    }

    public void validate() throws TException {
      // check for required fields
    }

  }

}
